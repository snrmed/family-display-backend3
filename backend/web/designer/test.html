<!DOCTYPE html>

<!-- This is the fully patched Kin:D Display Designer HTML (SVG Enhanced v2.2) -->

<!-- Changes: JSON export keeps text font size, new text/icons start black, dad joke placeholder -->

<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>kin;D Display Designer - SVG Enhanced v2.2</title>
<style>
/* CSS Variables */
:root{
  --panel:#0f0f11;
  --panel2:#1a1a1e;
  --text:#eee;
  --muted:#9aa0a6;
  --accent:#00d9b8;
  --brand:#00d9b8;
  --border:#2a2a2e;
  --hover:#242428;
}

/* Custom Fonts */
@font-face {
font-family: â€˜Interâ€™;
src: url(â€˜fonts/Inter/Inter-VariableFont_slnt,wght.ttfâ€™) format(â€˜truetypeâ€™);
font-weight: 100 900;
font-display: swap;
}
@font-face {
font-family: â€˜Robotoâ€™;
src: url(â€˜fonts/Roboto/Roboto-Regular.ttfâ€™) format(â€˜truetypeâ€™);
font-weight: 400;
font-display: swap;
}
@font-face {
font-family: â€˜Atkinson Hyperlegibleâ€™;
src: url(â€˜fonts/AtkinsonHyperlegible/AtkinsonHyperlegible-Regular.ttfâ€™) format(â€˜truetypeâ€™);
font-weight: 400;
font-display: swap;
}
@font-face {
font-family: â€˜Source Sans 3â€™;
src: url(â€˜fonts/SourceSans3/SourceSans3-VariableFont_wght.ttfâ€™) format(â€˜truetypeâ€™);
font-weight: 200 900;
font-display: swap;
}
@font-face {
font-family: â€˜Public Sansâ€™;
src: url(â€˜fonts/PublicSans/PublicSans-VariableFont_wght.ttfâ€™) format(â€˜truetypeâ€™);
font-weight: 100 900;
font-display: swap;
}
@font-face {
font-family: â€˜Manropeâ€™;
src: url(â€˜fonts/Manrope/Manrope-VariableFont_wght.ttfâ€™) format(â€˜truetypeâ€™);
font-weight: 200 800;
font-display: swap;
}
@font-face {
font-family: â€˜Space Groteskâ€™;
src: url(â€˜fonts/SpaceGrotesk/SpaceGrotesk-VariableFont_wght.ttfâ€™) format(â€˜truetypeâ€™);
font-weight: 300 700;
font-display: swap;
}
@font-face {
font-family: â€˜Outfitâ€™;
src: url(â€˜fonts/Outfit/Outfit-VariableFont_wght.ttfâ€™) format(â€˜truetypeâ€™);
font-weight: 100 900;
font-display: swap;
}
@font-face {
font-family: â€˜Plus Jakarta Sansâ€™;
src: url(â€˜fonts/PlusJakartaSans/PlusJakartaSans-VariableFont_wght.ttfâ€™) format(â€˜truetypeâ€™);
font-weight: 200 800;
font-display: swap;
}
@font-face {
font-family: â€˜Merriweatherâ€™;
src: url(â€˜fonts/Merriweather/Merriweather-Regular.ttfâ€™) format(â€˜truetypeâ€™);
font-weight: 400;
font-display: swap;
}
@font-face {
font-family: â€˜Noto Sansâ€™;
src: url(â€˜fonts/NotoSans/NotoSans-Regular.ttfâ€™) format(â€˜truetypeâ€™);
font-weight: 400;
font-display: swap;
}

/* Base Styles */
*{
box-sizing:border-box;
user-select:none;
-webkit-user-select:none;
-moz-user-select:none;
-ms-user-select:none;
}
html,body{height:100%;margin:0}
body{
background:#0a0a0c;
color:var(â€“text);
font-family:system-ui,â€˜Segoe UIâ€™,sans-serif;
overflow:hidden;
font-size:14px;
}

/* Allow text selection only in input fields */
input,textarea,select{
user-select:text;
-webkit-user-select:text;
-moz-user-select:text;
-ms-user-select:text;
}

/* Grid Layout */
.app{
display:grid;
grid-template-columns:1fr 420px;
grid-template-rows:auto 1fr 40px;
gap:0;
height:100vh;
}

/* Header */
header{
grid-column:1/3;
background:linear-gradient(135deg,#0f0f11 0%,#1a1a1e 100%);
border-bottom:1px solid var(â€“border);
padding:12px 20px;
display:flex;
align-items:center;
gap:12px;
box-shadow:0 2px 8px rgba(0,0,0,.3);
flex-wrap:wrap;
}
.brand{
font-size:20px;
font-weight:700;
color:var(â€“brand);
letter-spacing:-0.5px;
}
.brand-tagline{
color:var(â€“muted);
font-size:11px;
font-weight:300;
text-transform:uppercase;
letter-spacing:1px;
margin-right:auto;
}
header .divider{
width:1px;
height:24px;
background:var(â€“border);
margin:0 4px;
}

/* Canvas Stage */
.stage-wrap{
grid-row:2;
grid-column:1;
display:flex;
justify-content:center;
align-items:flex-start;
overflow:auto;
padding:60px;
background:#0a0a0c;
}
#zoomStage{
transform-origin:top left;
display:inline-block;
transition:transform 0.2s ease;
position:relative;
}
#canvas{
position:relative;
width:800px;
height:480px;
border:1px solid #333;
border-radius:8px;
overflow:visible;
background:#111;
box-shadow:0 8px 32px rgba(0,0,0,.6);
}
/* Canvas boundary indicator */
#canvas::after{
content:â€™â€™;
position:absolute;
inset:-40px;
border:2px dashed rgba(0,217,184,0.2);
border-radius:12px;
pointer-events:none;
z-index:0;
}
#bg{
position:absolute;
inset:0;
width:100%;
height:100%;
object-fit:cover;
z-index:0;
pointer-events:none;
}

/* Grid Overlay */
.grid-overlay{
position:absolute;
inset:0;
pointer-events:none;
z-index:1;
display:none;
}
.grid-overlay.active{display:block}
.grid-overlay line{
stroke:var(â€“brand);
stroke-width:0.5;
opacity:0.3;
}

/* Elements */
.el{
position:absolute;
user-select:none;
z-index:5;
cursor:move;
transition:outline 0.15s ease;
font-family:â€˜Robotoâ€™, system-ui, sans-serif;
}
.box{
background:rgba(255,255,255,.16);
border:1px solid rgba(255,255,255,.45);
border-radius:12px;
padding:10px;
backdrop-filter:blur(8px);
}

/* SVG Element Styles */
.svg-overlay{
display:flex;
align-items:center;
justify-content:center;
overflow:hidden;
}
.svg-overlay svg{
width:100%;
height:100%;
object-fit:contain;
}

/* Themed Box Styles */
.box-abstract{
background:linear-gradient(135deg, rgba(255,100,150,.3) 0%, rgba(100,200,255,.3) 100%);
border:2px solid rgba(255,255,255,.6);
border-radius:24px;
box-shadow:0 8px 32px rgba(0,0,0,.3);
}

.box-geometric{
background:rgba(255,255,255,.25);
border:3px solid rgba(255,255,255,.8);
border-radius:0px;
clip-path:polygon(0 0, 100% 0, 100% 90%, 95% 100%, 0 100%);
}

.box-paper-collage{
background:rgba(255,245,230,.9);
border:none;
border-radius:4px;
box-shadow:3px 3px 8px rgba(0,0,0,.4), -2px -2px 6px rgba(255,255,255,.3);
transform:rotate(-0.5deg);
}

.box-kids-shapes{
background:linear-gradient(45deg, rgba(255,200,100,.7) 0%, rgba(255,150,200,.7) 100%);
border:4px solid #fff;
border-radius:32px;
box-shadow:0 6px 20px rgba(255,100,150,.4);
}

.box-minimal{
background:rgba(255,255,255,.15);
border:1px solid rgba(255,255,255,.3);
border-radius:16px;
backdrop-filter:blur(10px);
}

.text,.icon{
background:transparent !important;
border:none;
padding:0;
color:#000;
}
.el-content{
width:100%;
height:100%;
display:flex;
align-items:center;
justify-content:center;
pointer-events:none;
}
.box .el-content{
pointer-events:auto;
}
.icon .el-content{
font-family: â€œApple Color Emojiâ€, â€œSegoe UI Emojiâ€, â€œNoto Color Emojiâ€, â€œAndroid Emojiâ€, â€œEmojiSymbolsâ€, sans-serif;
line-height:1;
pointer-events:auto;
}
.text .el-content{
line-height:1.15;
white-space:pre-wrap;
pointer-events:auto;
}
.selected{
outline:2px solid var(â€“brand);
outline-offset:2px;
animation:pulse 2s ease-in-out infinite;
}
.multi-selected{
outline:2px solid #ffa500;
outline-offset:2px;
animation:pulse-multi 2s ease-in-out infinite;
}
@keyframes pulse{
0%,100%{outline-color:var(â€“brand)}
50%{outline-color:rgba(0,217,184,0.5)}
}
@keyframes pulse-multi{
0%,100%{outline-color:#ffa500}
50%{outline-color:rgba(255,165,0,0.5)}
}

/* Resize handle */
.resize-handle{
position:absolute;
bottom:-6px;
right:-6px;
width:14px;
height:14px;
background:var(â€“brand);
border-radius:50%;
cursor:nwse-resize;
z-index:100;
box-shadow:0 2px 6px rgba(0,0,0,0.4);
display:none;
pointer-events:auto;
border:2px solid #fff;
}
.selected .resize-handle,
.multi-selected .resize-handle{
display:block;
}

/* Sidebar */
.sidebar{
grid-row:2/4;
grid-column:2;
background:var(â€“panel);
border-left:1px solid var(â€“border);
display:flex;
flex-direction:column;
overflow:auto;
}
.panel{
padding:16px;
border-bottom:1px solid var(â€“border);
background:var(â€“panel2);
}
.panel:hover{background:#1c1c20}
.panel h3{
margin:0 0 12px 0;
font-size:13px;
font-weight:700;
text-transform:uppercase;
letter-spacing:0.5px;
cursor:pointer;
display:flex;
align-items:center;
gap:8px;
user-select:none;
}
.panel .toggle-icon{
margin-left:auto;
font-size:10px;
transition:transform 0.2s ease;
}
.panel.collapsed .toggle-icon{
transform:rotate(-90deg);
}
.panel.collapsed .panel-content{
display:none;
}
.panel-content{
display:block;
}

.row{
display:flex;
gap:8px;
margin-bottom:8px;
align-items:center;
}

label{
display:flex;
flex-direction:column;
gap:4px;
font-size:11px;
font-weight:600;
color:var(â€“muted);
}

input[type=â€œtextâ€],
input[type=â€œnumberâ€],
select,
textarea{
background:var(â€“panel);
border:1px solid var(â€“border);
border-radius:6px;
padding:8px 10px;
color:var(â€“text);
font-size:13px;
}

input[type=â€œtextâ€]:focus,
input[type=â€œnumberâ€]:focus,
select:focus,
textarea:focus{
outline:none;
border-color:var(â€“brand);
background:#17171b;
}

input[type=â€œcolorâ€]{
width:40px;
height:40px;
border:1px solid var(â€“border);
border-radius:6px;
cursor:pointer;
background:var(â€“panel);
}

input[type=â€œrangeâ€]{
flex:1;
height:4px;
border-radius:2px;
background:var(â€“border);
outline:none;
-webkit-appearance:none;
}
input[type=â€œrangeâ€]::-webkit-slider-thumb{
-webkit-appearance:none;
appearance:none;
width:14px;
height:14px;
border-radius:50%;
background:var(â€“brand);
cursor:pointer;
box-shadow:0 1px 4px rgba(0,0,0,.4);
}
input[type=â€œrangeâ€]::-moz-range-thumb{
width:14px;
height:14px;
border-radius:50%;
background:var(â€“brand);
cursor:pointer;
border:none;
box-shadow:0 1px 4px rgba(0,0,0,.4);
}

button{
background:var(â€“panel);
border:1px solid var(â€“border);
border-radius:6px;
padding:8px 14px;
color:var(â€“text);
font-size:12px;
font-weight:600;
cursor:pointer;
transition:all 0.15s ease;
}
button:hover:not(:disabled){
background:var(â€“hover);
border-color:var(â€“brand);
}
button:active:not(:disabled){
transform:translateY(1px);
}
button:disabled{
opacity:0.4;
cursor:not-allowed;
}
button.primary{
background:linear-gradient(135deg, var(â€“brand) 0%, #00b09b 100%);
border:none;
color:#fff;
box-shadow:0 2px 8px rgba(0,217,184,0.3);
}
button.primary:hover:not(:disabled){
box-shadow:0 4px 12px rgba(0,217,184,0.4);
transform:translateY(-1px);
}
button.tiny{
padding:6px 10px;
font-size:11px;
}

/* Quick Add */
.quick-add{
display:grid;
grid-template-columns:repeat(3, 1fr);
gap:8px;
}
.quick-add-btn{
aspect-ratio:1;
background:var(â€“panel);
border:1px solid var(â€“border);
border-radius:8px;
display:flex;
flex-direction:column;
align-items:center;
justify-content:center;
gap:6px;
cursor:pointer;
transition:all 0.15s ease;
}
.quick-add-btn:hover{
background:var(â€“hover);
border-color:var(â€“brand);
transform:translateY(-2px);
box-shadow:0 4px 12px rgba(0,0,0,.3);
}
.quick-add-btn .icon{
font-size:28px;
opacity:0.9;
}
.quick-add-btn .label{
font-size:10px;
font-weight:600;
color:var(â€“muted);
text-transform:uppercase;
letter-spacing:0.5px;
}

/* Info Dropdown */
.info-dropdown{
display:none;
position:absolute;
background:var(â€“panel);
border:1px solid var(â€“brand);
border-radius:8px;
padding:8px;
z-index:1000;
box-shadow:0 8px 24px rgba(0,0,0,.6);
min-width:200px;
}
.info-dropdown.show{display:block}
.info-option{
padding:10px 12px;
cursor:pointer;
border-radius:4px;
margin:4px 0;
transition:background 0.15s ease;
}
.info-option:hover{
background:var(â€“hover);
}

/* Status Bar */
.status-bar{
grid-row:3;
grid-column:1;
background:var(â€“panel);
border-top:1px solid var(â€“border);
padding:0 20px;
display:flex;
align-items:center;
gap:20px;
font-size:11px;
color:var(â€“muted);
}
.status-item{
display:flex;
align-items:center;
gap:6px;
}
.status-dot{
width:6px;
height:6px;
border-radius:50%;
background:var(â€“brand);
animation:blink 2s ease-in-out infinite;
}
@keyframes blink{
0%,100%{opacity:1}
50%{opacity:0.3}
}

/* Value Pills */
.value-pill{
background:#222;
border:1px solid var(â€“border);
border-radius:6px;
padding:4px 8px;
font-size:11px;
color:var(â€“brand);
font-weight:600;
font-family:monospace;
}

/* Output */
#output{
white-space:pre;
background:#0b0b0b;
border:1px solid var(â€“border);
border-radius:8px;
padding:12px;
max-height:150px;
overflow:auto;
font-family:monospace;
font-size:11px;
line-height:1.5;
color:#6dd3ae;
}

/* Test Mode Badge */
.test-badge{
position:absolute;
top:10px;
left:10px;
background:#ff6b6b;
color:#fff;
padding:6px 12px;
border-radius:6px;
font-size:11px;
font-weight:700;
z-index:100;
box-shadow:0 2px 8px rgba(255,107,107,.4);
}

/* Scrollbars */
::-webkit-scrollbar{width:8px;height:8px}
::-webkit-scrollbar-track{background:var(â€“panel)}
::-webkit-scrollbar-thumb{background:var(â€“border);border-radius:4px}
::-webkit-scrollbar-thumb:hover{background:#3a3a3e}

/* Slider containers */
.slider-group{
display:flex;
flex-direction:column;
gap:4px;
margin:8px 0;
}
.slider-row{
display:flex;
align-items:center;
gap:8px;
}
.slider-row input[type=â€œrangeâ€]{
flex:1;
}
</style>

</head>
<body>

<div class="app">
  <header>
    <div class="brand">kin;D</div>
    <span class="brand-tagline">SVG Enhanced v2.2</span>
    <div class="divider"></div>

```
<label style="color:#eee">Zoom
  <input type="range" id="zoomSlider" min="25" max="175" value="100">
  <span id="zoomLabel" class="value-pill">100%</span>
</label>
<button id="fitBtn" class="tiny">Fit</button>

<div class="divider"></div>

<label>Preset
  <select id="templateSelect" style="width:180px"></select>
</label>

<label>Theme
  <select id="pexelsTheme">
    <option value="abstract">Abstract</option>
    <option value="nature">Nature</option>
    <option value="family">Family</option>
    <option value="kids">Kids</option>
    <option value="minimal">Minimal</option>
    <option value="geometric">Geometric</option>
    <option value="paper-collage">Paper Collage</option>
    <option value="modern-art">Modern Art</option>
    <option value="home">Home</option>
    <option value="weather">Weather</option>
  </select>
</label>

<div style="flex:1"></div>

<button id="mockPreviewBtn" class="tiny primary" title="Load mock data">ğŸ­ Mock Preview</button>
<button id="resetBtn" class="tiny" title="Reset to original preset">â†» Reset</button>
<button id="undoBtn" class="tiny" title="Undo (Ctrl+Z)">â†¶ Undo</button>
<button id="redoBtn" class="tiny" title="Redo (Ctrl+Y)">â†· Redo</button>
<button id="saveJsonBtn" class="primary tiny" title="Save JSON to file">ğŸ’¾ Save JSON</button>
```

  </header>

  <div class="stage-wrap">
    <div id="zoomStage">
      <div id="canvas">
        <div class="test-badge">TEST MODE</div>
        <img id="bg" alt="background" crossorigin="anonymous">
        <svg class="grid-overlay" id="gridOverlay"></svg>
      </div>
    </div>
  </div>

  <div class="sidebar">
    <div class="panel">
      <h3>ğŸ¨ Preset Settings</h3>
      <div class="row">
        <label style="flex:1">Preset Name
          <input type="text" id="presetName" placeholder="my_custom_preset" style="width:100%">
        </label>
      </div>
      <div style="font-size:10px;color:var(--muted);margin-top:4px">
        ğŸ’¡ Used as filename when exporting JSON
      </div>
    </div>

```
<div class="panel">
  <h3>âŠ• Quick Add</h3>
  <div class="quick-add">
    <div class="quick-add-btn" id="quickAddBox">
      <span class="icon">â–¡</span>
      <div class="label">Add Box</div>
    </div>
    <div class="quick-add-btn" id="quickAddInfo">
      <span class="icon">â„¹ï¸</span>
      <div class="label">Add Info</div>
    </div>
    <div class="quick-add-btn" id="quickAddSVG">
      <span class="icon">ğŸ¨</span>
      <div class="label">Add SVG</div>
    </div>
  </div>
  <div class="info-dropdown" id="infoDropdown">
    <div class="info-option" data-type="WEATHER_CITY">ğŸ™ City</div>
    <div class="info-option" data-type="WEATHER_MINMAX">ğŸŒ¡ Temperature</div>
    <div class="info-option" data-type="WEATHER_NOTE">â˜ï¸ Condition</div>
    <div class="info-option" data-type="WEATHER_ICON">â˜€ Weather Icon</div>
    <div class="info-option" data-type="JOKE">ğŸ˜„ Dad Joke</div>
    <div class="info-option" data-type="DATE">ğŸ“… Date</div>
    <div class="info-option" data-type="">ğŸ“ Static Text</div>
  </div>
  <div class="row" style="margin-top:12px">
    <button id="deleteBtn" class="tiny" style="background:#4a1a1a;border-color:#6a2a2a">ğŸ—‘ Delete</button>
  </div>
  <input type="file" id="svgFileInput" accept=".svg" style="display:none">
</div>

<div class="panel" id="inspectPanel">
  <h3>ğŸ” Inspector</h3>
  <div class="row">
    <span id="inspectType" style="color:var(--brand);font-weight:600">Nothing selected</span>
  </div>
  <div class="row">
    <label>X
      <input type="number" id="inspectX" min="0" max="800" step="1" style="width:70px" disabled>
    </label>
    <label>Y
      <input type="number" id="inspectY" min="0" max="480" step="1" style="width:70px" disabled>
    </label>
  </div>
  <div class="row">
    <label>Width
      <input type="number" id="inspectW" min="10" max="800" step="10" style="width:80px" disabled>
    </label>
    <label>Height
      <input type="number" id="inspectH" min="10" max="480" step="10" style="width:80px" disabled>
    </label>
  </div>
</div>

<div class="panel" id="svgStylePanel">
  <h3>ğŸ¨ SVG Styling <span class="toggle-icon">â–¼</span></h3>
  <div class="panel-content">
    <div class="slider-group">
      <div class="slider-row">
        <label style="min-width:90px">Opacity</label>
        <input type="range" id="svgOpacity" min="0" max="100" value="100" disabled>
        <span id="svgOpacityVal" class="value-pill">100%</span>
      </div>
      <div class="slider-row">
        <label style="min-width:90px">Rotation</label>
        <input type="range" id="svgRotation" min="0" max="360" value="0" disabled>
        <span id="svgRotationVal" class="value-pill">0Â°</span>
      </div>
    </div>
    <div class="row">
      <button id="svgRotateLeft" class="tiny" disabled>â†¶ -15Â°</button>
      <button id="svgRotate90" class="tiny" disabled>âŸ³ 90Â°</button>
      <button id="svgRotateRight" class="tiny" disabled>â†· +15Â°</button>
      <button id="svgResetRotation" class="tiny" disabled>â†º Reset</button>
    </div>
    <div class="row">
      <label style="flex:1">Fill Type
        <select id="svgFillType" style="width:100%" disabled>
          <option value="none">None (Original)</option>
          <option value="solid">Solid Color</option>
          <option value="gradient">Linear Gradient</option>
        </select>
      </label>
    </div>
    <div id="svgSolidColorSection" style="display:none">
      <div class="row">
        <label>Fill Color
          <input type="color" id="svgFillColor" value="#000000" disabled>
        </label>
      </div>
    </div>
    <div id="svgGradientSection" style="display:none">
      <div class="row">
        <label>Start Color
          <input type="color" id="svgGradStart" value="#ff0000" disabled>
        </label>
        <label>End Color
          <input type="color" id="svgGradEnd" value="#0000ff" disabled>
        </label>
      </div>
      <div class="row">
        <label style="flex:1">Gradient Angle
          <input type="range" id="svgGradAngle" min="0" max="360" value="45" style="width:100%" disabled>
          <span id="svgGradAngleVal" class="value-pill">45Â°</span>
        </label>
      </div>
    </div>
    <div class="row">
      <button id="applySVGStyle" class="tiny primary" disabled>ğŸ’¾ Save Changes</button>
    </div>
    <div style="font-size:10px;color:var(--muted);margin-top:4px">
      ğŸ’¡ Style updates live as you adjust. Click Save to add to undo history.
    </div>
  </div>
</div>

<div class="panel" id="boxStylePanel">
  <h3>ğŸ¨ Box Styling <span class="toggle-icon">â–¼</span></h3>
  <div class="panel-content">
  <div class="slider-group">
    <div class="slider-row">
      <label style="min-width:90px">Opacity</label>
      <input type="range" id="boxOpacity" min="0" max="100" value="100" disabled>
      <span id="boxOpacityVal" class="value-pill">100%</span>
    </div>
    <div class="slider-row">
      <label style="min-width:90px">Border Width</label>
      <input type="range" id="boxBorderWidth" min="0" max="10" value="1" disabled>
      <span id="boxBorderWidthVal" class="value-pill">1px</span>
    </div>
    <div class="slider-row">
      <label style="min-width:90px">Border Radius</label>
      <input type="range" id="boxBorderRadius" min="0" max="50" value="12" disabled>
      <span id="boxBorderRadiusVal" class="value-pill">12px</span>
    </div>
  </div>
  <div class="row">
    <label>BG Color
      <input type="color" id="boxBgColor" value="#ffffff" disabled>
    </label>
    <label>Border Color
      <input type="color" id="boxBorderColor" value="#ffffff" disabled>
    </label>
  </div>
  <div class="row">
    <label style="flex:1">Shadow Type
      <select id="boxShadowType" style="width:100%" disabled>
        <option value="none">None</option>
        <option value="light">Light Drop</option>
        <option value="dark">Dark Drop</option>
        <option value="inset">Internal (Inset)</option>
        <option value="glow">Glow</option>
      </select>
    </label>
  </div>
  <div class="row">
    <label>Shadow Color
      <input type="color" id="boxShadowColor" value="#000000" disabled>
    </label>
  </div>
  <div class="row">
    <label>Shadow Intensity
      <input type="range" id="boxShadowIntensity" min="1" max="5" value="1" step="0.5" style="width:120px" disabled>
      <span id="boxShadowIntensityVal" class="value-pill">1x</span>
    </label>
  </div>
  <div class="row">
    <label style="flex:1">Preset Style
      <select id="boxStyle" style="width:100%" disabled>
        <option value="custom">Custom (Manual)</option>
        <option value="default">Default (Glass)</option>
        <option value="abstract">Abstract (Gradient)</option>
        <option value="geometric">Geometric (Angular)</option>
        <option value="paper-collage">Paper Collage (Textured)</option>
        <option value="kids-shapes">Kids Shapes (Playful)</option>
        <option value="minimal">Minimal (Clean)</option>
      </select>
    </label>
  </div>
  </div>
</div>


<div class="panel" id="customCSSPanel">
  <h3>ğŸ¨ Custom CSS <span class="toggle-icon">â–¼</span></h3>
  <div class="panel-content">
    <div class="row">
      <label style="flex:1; font-size:11px; color:var(--muted)">
        Apply custom CSS to selected element (also works with UIverse.io snippets!)
      </label>
    </div>
    <div class="row">
      <textarea id="customCSS" rows="6" style="width:100%; font-family:monospace; font-size:11px; background:var(--panel); color:var(--text); border:1px solid var(--border); border-radius:4px; padding:8px;" placeholder="/* Paste CSS here, including from UIverse.io */&#10;background: linear-gradient(45deg, #ff0000, #00ff00);&#10;border: 2px solid blue;&#10;box-shadow: 0 4px 8px rgba(0,0,0,0.3);" disabled></textarea>
    </div>
    <div class="row">
      <button id="applyCustomCSS" class="tiny primary" disabled>Apply CSS</button>
      <button id="saveCustomCSS" class="tiny">ğŸ’¾ Save</button>
      <button id="loadCustomCSS" class="tiny">ğŸ“‚ Load</button>
    </div>
    <div class="row">
      <select id="savedCSSList" style="width:100%; font-size:11px;" disabled>
        <option value="">-- Saved CSS Presets --</option>
      </select>
    </div>
  </div>
</div>

<div class="panel" id="textControlPanel">
  <h3>ğŸ–‹ Text & Icon <span class="toggle-icon">â–¼</span></h3>
  <div class="panel-content">
  <div class="row">
    <label style="flex:1">Content
      <input type="text" id="textElContent" style="width:100%" disabled>
    </label>
  </div>
  <div class="row">
    <label style="flex:1">Data Type
      <select id="textElType" style="width:100%" disabled>
        <option value="">Static Text</option>
        <optgroup label="Weather">
          <option value="WEATHER_CITY">Weather: City</option>
          <option value="WEATHER_MINMAX">Weather: Min/Max Temp</option>
          <option value="WEATHER_NOTE">Weather: Condition</option>
          <option value="WEATHER_ICON">Weather: Icon</option>
        </optgroup>
        <optgroup label="Content">
          <option value="JOKE">Dad Joke</option>
          <option value="DATE">Current Date</option>
        </optgroup>
      </select>
    </label>
  </div>
  <div class="row">
    <label>Font Size
      <input type="range" id="textSize" min="8" max="120" value="16" style="width:120px" disabled>
      <span id="textSizeVal" class="value-pill">16px</span>
    </label>
  </div>
  <div class="row">
    <label>Font Weight
      <select id="fontWeight" style="width:120px" disabled>
        <option value="300">Light</option>
        <option value="400" selected>Regular</option>
        <option value="700">Bold</option>
      </select>
    </label>
    <label>Color
      <input type="color" id="textColor" disabled>
    </label>
  </div>
  <div class="row">
    <label style="flex:1">Font Family
      <select id="fontFamily" style="width:100%" disabled>
        <option value="Roboto">Roboto (Default)</option>
        <option value="Inter">Inter</option>
        <option value="Atkinson Hyperlegible">Atkinson Hyperlegible</option>
        <option value="Source Sans 3">Source Sans 3</option>
        <option value="Public Sans">Public Sans</option>
        <option value="Manrope">Manrope</option>
        <option value="Space Grotesk">Space Grotesk</option>
        <option value="Outfit">Outfit</option>
        <option value="Plus Jakarta Sans">Plus Jakarta Sans</option>
        <option value="Merriweather">Merriweather</option>
        <option value="Noto Sans">Noto Sans</option>
      </select>
    </label>
  </div>
  
  <!-- NEW: Text Shadow/Glow Controls -->
  <div class="row">
    <label style="flex:1">Shadow Type
      <select id="textShadowType" style="width:100%" disabled>
        <option value="none">None</option>
        <option value="light">Light Drop</option>
        <option value="dark">Dark Drop</option>
        <option value="glow">Glow</option>
        <option value="outline">Outline</option>
      </select>
    </label>
  </div>
  <div class="row">
    <label>Shadow Color
      <input type="color" id="textShadowColor" value="#000000" disabled>
    </label>
  </div>
  <div class="row">
    <label>Shadow Intensity
      <input type="range" id="textShadowIntensity" min="1" max="5" value="1" step="0.5" style="width:120px" disabled>
      <span id="textShadowIntensityVal" class="value-pill">1x</span>
    </label>
  </div>
  
  <!-- NEW: Multi-Select Apply Controls -->
  <div id="multiSelectControls" style="display:none; margin-top:12px; padding-top:12px; border-top:1px solid var(--border)">
    <div style="font-size:10px;color:var(--brand);margin-bottom:8px;font-weight:600">
      ğŸ¯ MULTI-SELECT MODE (<span id="multiSelectCount">0</span> selected)
    </div>
    <div class="row">
      <button id="applyColorToAll" class="tiny primary" style="flex:1">Apply Color to All</button>
    </div>
    <div class="row">
      <button id="applyShadowToAll" class="tiny primary" style="flex:1">Apply Shadow to All</button>
    </div>
  </div>
  
  </div>
</div>

<div class="panel">
  <h3>âŠ Alignment</h3>
  <div class="row">
    <button id="alignLeft" class="tiny">âŠ£ Left</button>
    <button id="alignCenter" class="tiny">âŠ¢âŠ£ Center</button>
    <button id="alignRight" class="tiny">âŠ¢ Right</button>
  </div>
  <div class="row">
    <button id="alignTop" class="tiny">âŠ¤ Top</button>
    <button id="alignMiddle" class="tiny">âŠ¥âŠ¤ Middle</button>
    <button id="alignBottom" class="tiny">âŠ¥ Bottom</button>
  </div>
  <div class="row">
    <button id="bringToCanvas" class="tiny" style="background:#1a4a4a;border-color:#2a6a6a">â†© Bring to Canvas</button>
  </div>
  <div class="row">
    <label><input type="checkbox" id="snapToGrid"> Snap (16px)</label>
    <button id="toggleGrid" class="tiny">Grid</button>
  </div>
  <div style="font-size:10px;color:var(--muted);margin-top:8px">
    ğŸ’¡ Hold Shift+Click to multi-select text elements
  </div>
</div>

<div class="panel">
  <h3>ğŸ“¤ Export & Test</h3>
  <div class="row">
    <button id="btnDownloadPNG" class="tiny">ğŸ“¸ PNG</button>
    <button id="btnExportJSON" class="tiny">ğŸ“‹ JSON</button>
  </div>
  <div class="row">
    <button id="btnImport" class="tiny">ğŸ“‚ Import JSON</button>
    <input type="file" id="importFile" accept=".json" style="display:none">
  </div>
  <div style="font-size:10px;color:var(--muted);margin-top:4px">
    âš™ï¸ PNG export: Full-resolution image<br>
    ğŸ“‹ JSON export: Editable layout config<br>
    ğŸ“‚ Import: Load saved JSON layout
  </div>
</div>

<div class="panel">
  <h3>ğŸ’¬ JSON Output</h3>
  <div id="output"></div>
</div>
```

  </div>

  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot"></div>
      <span id="statusText">Ready</span>
    </div>
  </div>
</div>

<canvas id="exportCanvas" width="800" height="480" style="display:none"></canvas>

<script>
// ====== CONSTANTS ======
const GRID_SIZE = 16;
const canvas = document.getElementById('canvas');
const gridOverlay = document.getElementById('gridOverlay');
const templateSelect = document.getElementById('templateSelect');
const presetNameInput = document.getElementById('presetName');

// Inspector elements
const textElContent = document.getElementById('textElContent');
const textElType = document.getElementById('textElType');
const textColor = document.getElementById('textColor');

// Box styling elements
const boxOpacity = document.getElementById('boxOpacity');
const boxBorderWidth = document.getElementById('boxBorderWidth');
const boxBorderRadius = document.getElementById('boxBorderRadius');
const boxBgColor = document.getElementById('boxBgColor');
const boxBorderColor = document.getElementById('boxBorderColor');
const boxShadowType = document.getElementById('boxShadowType');
const boxShadowColor = document.getElementById('boxShadowColor');
const boxShadowIntensity = document.getElementById('boxShadowIntensity');
const boxStyle = document.getElementById('boxStyle');

// Text shadow elements - NEW
const textShadowType = document.getElementById('textShadowType');
const textShadowColor = document.getElementById('textShadowColor');
const textShadowIntensity = document.getElementById('textShadowIntensity');

// SVG styling elements
const svgOpacity = document.getElementById('svgOpacity');
const svgRotation = document.getElementById('svgRotation');
const svgFillType = document.getElementById('svgFillType');
const svgFillColor = document.getElementById('svgFillColor');
const svgGradStart = document.getElementById('svgGradStart');
const svgGradEnd = document.getElementById('svgGradEnd');
const svgGradAngle = document.getElementById('svgGradAngle');
const applySVGStyle = document.getElementById('applySVGStyle');
const svgRotateLeft = document.getElementById('svgRotateLeft');
const svgRotate90 = document.getElementById('svgRotate90');
const svgRotateRight = document.getElementById('svgRotateRight');
const svgResetRotation = document.getElementById('svgResetRotation');

// Custom CSS elements
const customCSS = document.getElementById('customCSS');
const applyCustomCSS = document.getElementById('applyCustomCSS');
const savedCSSList = document.getElementById('savedCSSList');
const svgFileInput = document.getElementById('svgFileInput');

// State management
let selectedElements = [];
let selectedBoxForDrop = null;
let dragData = null;
let resizeData = null;
let currentPresetName = '';
let currentTemplateKey = '';
let originalTemplate = null;
let lastUsedTextColor = localStorage.getItem('lastUsedTextColor') || '#000000';

// Undo/Redo stacks
let actionHistory = [];
let historyIndex = -1;
const MAX_HISTORY = 50;

// ====== TEMPLATES ======
const TEMPLATES = {
  sticker_parade_dark: {
    name: 'Sticker Parade (Dark)',
    elements: [
      { kind:'text', x:40, y:60, w:240, h:70, text:'DARWIN', color:'#ffffff', weight:700, fontSize:48 },
      { kind:'text', x:40, y:120, w:200, h:40, text:'26Â° / 33Â°', type:'WEATHER_MINMAX', color:'#ffffff', weight:400, fontSize:28 },
      { kind:'icon', x:270, y:80, w:80, h:80, text:'â˜€', type:'WEATHER_ICON' },
      { kind:'text', x:40, y:180, w:320, h:50, text:'Partly Cloudy', type:'WEATHER_NOTE', color:'#cccccc', weight:400, fontSize:20 },
      { kind:'text', x:40, y:380, w:720, h:60, text:'Did you know? Penguins can jump up to 6 feet in the air!', type:'JOKE', color:'#dddddd', weight:400, fontSize:18 }
    ]
  },
  modern_clean: {
    name: 'Modern Clean',
    elements: [
      { kind:'box', x:40, y:40, w:300, h:120, style:'minimal', shadowType:'light' },
      { kind:'text', x:60, y:60, w:260, h:40, text:'Good Morning', color:'#ffffff', weight:700, fontSize:24 },
      { kind:'text', x:60, y:100, w:260, h:40, text:'Monday, Oct 27', type:'DATE', color:'#cccccc', weight:400, fontSize:16 },
      { kind:'box', x:40, y:180, w:720, h:80, style:'minimal', shadowType:'light' },
      { kind:'text', x:60, y:200, w:680, h:40, text:'Darwin â€¢ 26Â° / 33Â° â€¢ Sunny', type:'', color:'#ffffff', weight:400, fontSize:18 }
    ]
  }
};

// ====== UTILITIES ======
function parsePx(val) {
  return parseFloat(val) || 0;
}

function hexToRgba(hex, alpha = 1) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function rgbToHex(rgb) {
  const match = rgb.match(/\d+/g);
  if (!match) return '#000000';
  const r = parseInt(match[0]).toString(16).padStart(2, '0');
  const g = parseInt(match[1]).toString(16).padStart(2, '0');
  const b = parseInt(match[2]).toString(16).padStart(2, '0');
  return `#${r}${g}${b}`;
}

function snapToGrid(val) {
  return document.getElementById('snapToGrid').checked ? Math.round(val / GRID_SIZE) * GRID_SIZE : val;
}

function setStatus(msg, duration = 0) {
  document.getElementById('statusText').textContent = msg;
  if (duration > 0) {
    setTimeout(() => {
      document.getElementById('statusText').textContent = 'Ready';
    }, duration);
  }
}

// ====== THEMES ======
const themes = {
  abstract:        'https://images.pexels.com/photos/3137078/pexels-photo-3137078.jpeg?auto=compress&cs=tinysrgb&w=800&h=480&fit=crop',
  nature:          'https://images.pexels.com/photos/3225517/pexels-photo-3225517.jpeg?auto=compress&cs=tinysrgb&w=800&h=480&fit=crop',
  family:          'https://images.pexels.com/photos/4262420/pexels-photo-4262420.jpeg?auto=compress&cs=tinysrgb&w=800&h=480&fit=crop',
  kids:            'https://images.pexels.com/photos/3661385/pexels-photo-3661385.jpeg?auto=compress&cs=tinysrgb&w=800&h=480&fit=crop',
  minimal:         'https://images.pexels.com/photos/4068314/pexels-photo-4068314.jpeg?auto=compress&cs=tinysrgb&w=800&h=480&fit=crop',
  geometric:       'https://images.pexels.com/photos/1103970/pexels-photo-1103970.jpeg?auto=compress&cs=tinysrgb&w=800&h=480&fit=crop',
  'paper-collage': 'https://images.pexels.com/photos/6069832/pexels-photo-6069832.jpeg?auto=compress&cs=tinysrgb&w=800&h=480&fit=crop',
  'modern-art':    'https://images.pexels.com/photos/1585325/pexels-photo-1585325.jpeg?auto=compress&cs=tinysrgb&w=800&h=480&fit=crop',
  home:            'https://images.pexels.com/photos/3705530/pexels-photo-3705530.jpeg?auto=compress&cs=tinysrgb&w=800&h=480&fit=crop',
  weather:         'https://images.pexels.com/photos/3768/sky-sunny-clouds-cloudy.jpg?auto=compress&cs=tinysrgb&w=800&h=480&fit=crop'
};

function loadThemeBackground() {
  const theme = document.getElementById('pexelsTheme').value;
  const bg = document.getElementById('bg');
  // Set crossOrigin before src to avoid CORS issues in PNG export
  bg.crossOrigin = 'anonymous';
  bg.src = themes[theme] || '';
}

document.getElementById('pexelsTheme').onchange = loadThemeBackground;

// ====== MOCK DATA PREVIEW ======
document.getElementById('mockPreviewBtn').onclick = () => {
  [...canvas.querySelectorAll('.el')].forEach(el => {
    const type = el.dataset.type;
    if (type === 'WEATHER_CITY') setElText(el, 'Darwin');
    if (type === 'WEATHER_MINMAX') setElText(el, '26Â° / 33Â°');
    if (type === 'WEATHER_NOTE') setElText(el, 'Sunny');
    if (type === 'WEATHER_ICON') setElText(el, 'â˜€');
    if (type === 'JOKE') setElText(el, 'Why do cows wear bells? Because their horns don\'t work!');
    if (type === 'DATE') {
      const now = new Date();
      const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      setElText(el, `${days[now.getDay()]}, ${now.getDate()} ${months[now.getMonth()]}`);
    }
  });
  setStatus('Mock data loaded', 2000);
};

// ====== JSON EXPORT ======
document.getElementById('btnExportJSON').onclick = () => {
  const elements = [];
  [...canvas.querySelectorAll('.el')].forEach(el => {
    if (el.classList.contains('svg-overlay')) {
      elements.push({
        kind: 'svg',
        x: parsePx(el.style.left),
        y: parsePx(el.style.top),
        w: el.offsetWidth,
        h: el.offsetHeight,
        svgContent: el.dataset.svgContent,
        fillType: el.dataset.fillType || 'none',
        fillColor: el.dataset.fillColor,
        gradStart: el.dataset.gradStart,
        gradEnd: el.dataset.gradEnd,
        gradAngle: el.dataset.gradAngle,
        rotation: parseFloat(el.dataset.rotation || 0),
        opacity: parseFloat(el.style.opacity || 1),
        customCSS: el.dataset.customCSS
      });
    } else {
      const elData = {
        kind: el.classList.contains('box') ? 'box' : (el.classList.contains('icon') ? 'icon' : 'text'),
        x: parsePx(el.style.left),
        y: parsePx(el.style.top),
        w: el.offsetWidth,
        h: el.offsetHeight
      };
      
      if (elData.kind !== 'box') {
        elData.text = getElText(el);
        elData.color = el.style.color || '#000000';
        elData.fontSize = parseInt(el.style.fontSize) || 16;
        elData.weight = el.style.fontWeight || '400';
        if (el.style.fontFamily) {
          const fontFamily = el.style.fontFamily.split(',')[0].replace(/['"]/g, '').trim();
          if (fontFamily && fontFamily !== 'Roboto') elData.fontFamily = fontFamily;
        }
        if (el.dataset.type) elData.type = el.dataset.type;
        
        // NEW: Export text shadow data
        if (el.dataset.textShadowType && el.dataset.textShadowType !== 'none') {
          elData.textShadowType = el.dataset.textShadowType;
          elData.textShadowColor = el.dataset.textShadowColor || '#000000';
          elData.textShadowIntensity = parseFloat(el.dataset.textShadowIntensity || 1);
        }
      } else {
        if (el.dataset.boxStyle) elData.style = el.dataset.boxStyle;
        if (el.dataset.opacity) elData.opacity = parseFloat(el.dataset.opacity);
        if (el.dataset.bgColor) elData.bgColor = el.dataset.bgColor;
        if (el.style.borderWidth) elData.borderWidth = parseInt(el.style.borderWidth);
        if (el.style.borderRadius) elData.borderRadius = parseInt(el.style.borderRadius);
        if (el.style.borderColor) elData.borderColor = el.style.borderColor;
        if (el.dataset.shadowType) {
          elData.shadowType = el.dataset.shadowType;
          elData.shadowColor = el.dataset.shadowColor || '#000000';
          elData.shadowIntensity = parseFloat(el.dataset.shadowIntensity || 1);
        }
        if (el.dataset.customCSS) elData.customCSS = el.dataset.customCSS;
      }
      
      elements.push(elData);
    }
  });
  
  const json = JSON.stringify({ elements }, null, 2);
  document.getElementById('output').textContent = json;
  
  // NEW: Also trigger immediate download
  const blob = new Blob([json], { type: 'application/json' });
  const a = document.createElement('a');
  const name = presetNameInput.value.trim() || currentPresetName || 'kind-layout';
  a.download = `${name}.json`;
  a.href = URL.createObjectURL(blob);
  a.click();
  URL.revokeObjectURL(a.href);
  
  setStatus('JSON exported and downloaded âœ“', 2000);
};

document.getElementById('saveJsonBtn').onclick = () => {
  document.getElementById('btnExportJSON').click();
  const json = document.getElementById('output').textContent;
  const blob = new Blob([json], { type: 'application/json' });
  const a = document.createElement('a');
  const name = presetNameInput.value.trim() || currentPresetName || 'kind-layout';
  a.download = `${name}.json`;
  a.href = URL.createObjectURL(blob);
  a.click();
  setStatus('JSON file saved', 2000);
};

// ====== JSON IMPORT ======
document.getElementById('btnImport').onclick = () => document.getElementById('importFile').click();

document.getElementById('importFile').onchange = e => {
  const f = e.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = e => {
    try {
      const json = JSON.parse(e.target.result);
      renderLayout(json);
      if (json.theme) document.getElementById('pexelsTheme').value = json.theme;
      if (json.name) {
        currentPresetName = json.name;
        currentTemplateKey = json.name;
        presetNameInput.value = json.name;
      }
      originalTemplate = json;
      setStatus(`Imported: ${json.name || 'layout'} âœ“`, 2000);
    } catch (err) { 
      console.error('JSON Import Error:', err);
      setStatus('Invalid JSON file', 2000);
      alert('Failed to import JSON: ' + err.message);
    }
  };
  reader.readAsText(f);
  // Reset input so the same file can be imported again
  e.target.value = '';
};

// ====== UNDO/REDO ======
function saveAction(description = 'Action') {
  const state = {
    description,
    layout: {
      elements: [...canvas.querySelectorAll('.el')].map(el => {
        if (el.classList.contains('svg-overlay')) {
          return {
            kind: 'svg',
            x: parsePx(el.style.left),
            y: parsePx(el.style.top),
            w: el.offsetWidth,
            h: el.offsetHeight,
            svgContent: el.dataset.svgContent,
            fillType: el.dataset.fillType || 'none',
            fillColor: el.dataset.fillColor,
            gradStart: el.dataset.gradStart,
            gradEnd: el.dataset.gradEnd,
            gradAngle: el.dataset.gradAngle,
            rotation: parseFloat(el.dataset.rotation || 0),
            opacity: parseFloat(el.style.opacity || 1),
            customCSS: el.dataset.customCSS
          };
        } else {
          const elData = {
            kind: el.classList.contains('box') ? 'box' : (el.classList.contains('icon') ? 'icon' : 'text'),
            x: parsePx(el.style.left),
            y: parsePx(el.style.top),
            w: el.offsetWidth,
            h: el.offsetHeight
          };
          
          if (elData.kind !== 'box') {
            elData.text = getElText(el);
            elData.color = el.style.color || '#000000';
            elData.fontSize = parseInt(el.style.fontSize) || 16;
            elData.weight = el.style.fontWeight || '400';
            if (el.style.fontFamily) {
              const fontFamily = el.style.fontFamily.split(',')[0].replace(/['"]/g, '').trim();
              if (fontFamily && fontFamily !== 'Roboto') elData.fontFamily = fontFamily;
            }
            if (el.dataset.type) elData.type = el.dataset.type;
            
            // NEW: Save text shadow data in undo history
            if (el.dataset.textShadowType && el.dataset.textShadowType !== 'none') {
              elData.textShadowType = el.dataset.textShadowType;
              elData.textShadowColor = el.dataset.textShadowColor || '#000000';
              elData.textShadowIntensity = parseFloat(el.dataset.textShadowIntensity || 1);
            }
          } else {
            if (el.dataset.boxStyle) elData.style = el.dataset.boxStyle;
            if (el.dataset.opacity) elData.opacity = parseFloat(el.dataset.opacity);
            if (el.dataset.bgColor) elData.bgColor = el.dataset.bgColor;
            if (el.style.borderWidth) elData.borderWidth = parseInt(el.style.borderWidth);
            if (el.style.borderRadius) elData.borderRadius = parseInt(el.style.borderRadius);
            if (el.style.borderColor) elData.borderColor = el.style.borderColor;
            if (el.dataset.shadowType) {
              elData.shadowType = el.dataset.shadowType;
              elData.shadowColor = el.dataset.shadowColor || '#000000';
              elData.shadowIntensity = parseFloat(el.dataset.shadowIntensity || 1);
            }
            if (el.dataset.customCSS) elData.customCSS = el.dataset.customCSS;
          }
          
          return elData;
        }
      })
    }
  };
  
  actionHistory = actionHistory.slice(0, historyIndex + 1);
  actionHistory.push(state);
  
  if (actionHistory.length > MAX_HISTORY) {
    actionHistory.shift();
  } else {
    historyIndex++;
  }
  
  updateUndoRedoButtons();
}

function undo() {
  if (historyIndex <= 0) return;
  historyIndex--;
  const state = actionHistory[historyIndex];
  clearCanvas();
  renderLayout(state.layout, false);
  setStatus(`Undone: ${state.description}`, 1500);
  updateUndoRedoButtons();
}

function redo() {
  if (historyIndex >= actionHistory.length - 1) return;
  historyIndex++;
  const state = actionHistory[historyIndex];
  clearCanvas();
  renderLayout(state.layout, false);
  setStatus(`Redone: ${state.description}`, 1500);
  updateUndoRedoButtons();
}

function updateUndoRedoButtons() {
  document.getElementById('undoBtn').disabled = historyIndex <= 0;
  document.getElementById('redoBtn').disabled = historyIndex >= actionHistory.length - 1;
}

// ====== GRID ======
function drawGrid() {
  const svg = gridOverlay;
  svg.setAttribute('width', '800');
  svg.setAttribute('height', '480');
  svg.innerHTML = '';
  for (let x = GRID_SIZE; x < 800; x += GRID_SIZE) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x); line.setAttribute('y1', 0);
    line.setAttribute('x2', x); line.setAttribute('y2', 480);
    svg.appendChild(line);
  }
  for (let y = GRID_SIZE; y < 480; y += GRID_SIZE) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', 0); line.setAttribute('y1', y);
    line.setAttribute('x2', 800); line.setAttribute('y2', y);
    svg.appendChild(line);
  }
}

// ====== SVG HANDLING ======
function createSVGElement(svgContent, x = 100, y = 100, w = 200, h = 200) {
  const el = document.createElement('div');
  el.className = 'el svg-overlay';
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  el.style.width = w + 'px';
  el.style.height = h + 'px';
  
  // Store original SVG content
  el.dataset.svgContent = svgContent;
  el.dataset.fillType = 'none';
  el.dataset.rotation = '0';
  
  // Insert SVG
  el.innerHTML = svgContent;
  
  // Add resize handle
  const handle = document.createElement('div');
  handle.className = 'resize-handle';
  el.appendChild(handle);
  
  canvas.appendChild(el);
  return el;
}

function applySVGFill(el) {
  const fillType = el.dataset.fillType || 'none';
  const rotation = parseFloat(el.dataset.rotation || 0);
  const svg = el.querySelector('svg');
  if (!svg) return;
  
  // Apply rotation
  svg.style.transform = `rotate(${rotation}deg)`;
  svg.style.transformOrigin = 'center center';
  
  // Remove any existing gradient defs
  const existingDefs = svg.querySelector('defs');
  if (existingDefs) existingDefs.remove();
  
  // Get all fillable elements
  const fillableEls = svg.querySelectorAll('path, circle, rect, ellipse, polygon, polyline');
  
  if (fillType === 'solid') {
    const color = el.dataset.fillColor || '#000000';
    fillableEls.forEach(elem => {
      elem.setAttribute('fill', color);
    });
  } else if (fillType === 'gradient') {
    const startColor = el.dataset.gradStart || '#ff0000';
    const endColor = el.dataset.gradEnd || '#0000ff';
    const angle = parseFloat(el.dataset.gradAngle || 45);
    
    // Create gradient
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
    gradient.setAttribute('id', 'customGrad' + Date.now());
    
    // Calculate gradient direction from angle
    const rad = (angle - 90) * Math.PI / 180;
    const x1 = 50 + 50 * Math.cos(rad);
    const y1 = 50 + 50 * Math.sin(rad);
    const x2 = 50 - 50 * Math.cos(rad);
    const y2 = 50 - 50 * Math.sin(rad);
    
    gradient.setAttribute('x1', x1 + '%');
    gradient.setAttribute('y1', y1 + '%');
    gradient.setAttribute('x2', x2 + '%');
    gradient.setAttribute('y2', y2 + '%');
    
    const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop1.setAttribute('offset', '0%');
    stop1.setAttribute('style', `stop-color:${startColor};stop-opacity:1`);
    
    const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
    stop2.setAttribute('offset', '100%');
    stop2.setAttribute('style', `stop-color:${endColor};stop-opacity:1`);
    
    gradient.appendChild(stop1);
    gradient.appendChild(stop2);
    defs.appendChild(gradient);
    svg.insertBefore(defs, svg.firstChild);
    
    fillableEls.forEach(elem => {
      elem.setAttribute('fill', `url(#${gradient.id})`);
    });
  } else {
    // Restore original - reload from dataset
    el.innerHTML = el.dataset.svgContent;
    const handle = document.createElement('div');
    handle.className = 'resize-handle';
    el.appendChild(handle);
    
    // Reapply rotation to restored SVG
    const newSvg = el.querySelector('svg');
    if (newSvg) {
      newSvg.style.transform = `rotate(${rotation}deg)`;
      newSvg.style.transformOrigin = 'center center';
    }
  }
}

// SVG file import
document.getElementById('quickAddSVG').onclick = () => {
  svgFileInput.click();
};

svgFileInput.onchange = (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = (evt) => {
    saveAction('Import SVG');
    const svgContent = evt.target.result;
    const el = createSVGElement(svgContent, 300, 200, 200, 200);
    selectEl(el, false);
    setStatus('SVG imported', 2000);
  };
  reader.readAsText(file);
  
  // Reset input
  svgFileInput.value = '';
};

// SVG Style Controls - with live preview
function updateSVGLivePreview() {
  const el = getSelectedElement();
  if (el && el.classList.contains('svg-overlay')) {
    const fillType = svgFillType.value;
    el.dataset.fillType = fillType;
    
    if (fillType === 'solid') {
      el.dataset.fillColor = svgFillColor.value;
    } else if (fillType === 'gradient') {
      el.dataset.gradStart = svgGradStart.value;
      el.dataset.gradEnd = svgGradEnd.value;
      el.dataset.gradAngle = svgGradAngle.value;
    }
    
    const opacity = parseFloat(svgOpacity.value) / 100;
    el.style.opacity = opacity;
    
    // Update rotation
    const rotation = parseFloat(svgRotation.value);
    el.dataset.rotation = rotation;
    
    applySVGFill(el);
  }
}

svgFillType.addEventListener('change', (e) => {
  const el = getSelectedElement();
  if (el && el.classList.contains('svg-overlay')) {
    // Show/hide sections
    document.getElementById('svgSolidColorSection').style.display = 
      e.target.value === 'solid' ? 'block' : 'none';
    document.getElementById('svgGradientSection').style.display = 
      e.target.value === 'gradient' ? 'block' : 'none';
    
    // Live preview
    updateSVGLivePreview();
  }
});

// Live preview on opacity change
svgOpacity.addEventListener('input', (e) => {
  document.getElementById('svgOpacityVal').textContent = e.target.value + '%';
  updateSVGLivePreview();
});

// Live preview on rotation change
svgRotation.addEventListener('input', (e) => {
  document.getElementById('svgRotationVal').textContent = Math.round(e.target.value) + 'Â°';
  updateSVGLivePreview();
});

// Rotation quick buttons
svgRotateLeft.addEventListener('click', () => {
  const el = getSelectedElement();
  if (el && el.classList.contains('svg-overlay')) {
    const current = parseFloat(el.dataset.rotation || 0);
    const newRotation = (current - 15 + 360) % 360;
    svgRotation.value = newRotation;
    document.getElementById('svgRotationVal').textContent = Math.round(newRotation) + 'Â°';
    updateSVGLivePreview();
    saveAction('Rotate SVG');
  }
});

svgRotate90.addEventListener('click', () => {
  const el = getSelectedElement();
  if (el && el.classList.contains('svg-overlay')) {
    const current = parseFloat(el.dataset.rotation || 0);
    const newRotation = (current + 90) % 360;
    svgRotation.value = newRotation;
    document.getElementById('svgRotationVal').textContent = Math.round(newRotation) + 'Â°';
    updateSVGLivePreview();
    saveAction('Rotate SVG');
  }
});

svgRotateRight.addEventListener('click', () => {
  const el = getSelectedElement();
  if (el && el.classList.contains('svg-overlay')) {
    const current = parseFloat(el.dataset.rotation || 0);
    const newRotation = (current + 15) % 360;
    svgRotation.value = newRotation;
    document.getElementById('svgRotationVal').textContent = Math.round(newRotation) + 'Â°';
    updateSVGLivePreview();
    saveAction('Rotate SVG');
  }
});

svgResetRotation.addEventListener('click', () => {
  const el = getSelectedElement();
  if (el && el.classList.contains('svg-overlay')) {
    svgRotation.value = 0;
    document.getElementById('svgRotationVal').textContent = '0Â°';
    updateSVGLivePreview();
    saveAction('Reset SVG rotation');
  }
});

// Live preview on solid color change
svgFillColor.addEventListener('input', () => {
  updateSVGLivePreview();
});

// Live preview on gradient colors change
svgGradStart.addEventListener('input', () => {
  updateSVGLivePreview();
});

svgGradEnd.addEventListener('input', () => {
  updateSVGLivePreview();
});

// Live preview on gradient angle change
svgGradAngle.addEventListener('input', (e) => {
  document.getElementById('svgGradAngleVal').textContent = e.target.value + 'Â°';
  updateSVGLivePreview();
});

// Apply button saves the action to history
applySVGStyle.addEventListener('click', () => {
  const el = getSelectedElement();
  if (el && el.classList.contains('svg-overlay')) {
    saveAction('Apply SVG style');
    setStatus('SVG style saved', 2000);
  }
});

// ====== ELEMENT SELECTION ======
function selectEl(el, multiSelect = false) {
  if (!multiSelect) {
    document.querySelectorAll('.el.selected, .el.multi-selected').forEach(s => {
      s.classList.remove('selected', 'multi-selected');
    });
    selectedElements = [];
  }
  
  if (el) {
    if (selectedElements.includes(el)) {
      el.classList.remove('selected', 'multi-selected');
      selectedElements = selectedElements.filter(e => e !== el);
    } else {
      if (selectedElements.length === 0) {
        el.classList.add('selected');
      } else {
        el.classList.add('multi-selected');
        if (selectedElements[0]) {
          selectedElements[0].classList.remove('selected');
          selectedElements[0].classList.add('multi-selected');
        }
      }
      selectedElements.push(el);
      
      // NEW: Remove limit of 2 elements for text/icon multi-select
      // Only limit to 2 for alignment operations with boxes
      if (selectedElements.length > 10) {  // Increased from 2 to 10
        const removed = selectedElements.shift();
        removed.classList.remove('selected', 'multi-selected');
      }
    }
  }
  
  updateInspector();
  updateSelectedBoxForDrop();
  autoCollapsePanels();
  updateMultiSelectUI(); // NEW
}

function getSelectedElement() {
  return selectedElements.length > 0 ? selectedElements[0] : null;
}

function updateSelectedBoxForDrop() {
  selectedBoxForDrop = null;
  if (selectedElements.length === 1 && selectedElements[0].classList.contains('box')) {
    selectedBoxForDrop = selectedElements[0];
  }
}

// NEW: Update multi-select UI
function updateMultiSelectUI() {
  const multiSelectControls = document.getElementById('multiSelectControls');
  const multiSelectCount = document.getElementById('multiSelectCount');
  
  // Show multi-select controls if multiple text/icon elements are selected
  const textIconSelected = selectedElements.filter(el => 
    el.classList.contains('text') || el.classList.contains('icon')
  );
  
  if (textIconSelected.length > 1) {
    multiSelectControls.style.display = 'block';
    multiSelectCount.textContent = textIconSelected.length;
  } else {
    multiSelectControls.style.display = 'none';
  }
}

// ====== INSPECTOR ======
function updateInspector() {
  const el = getSelectedElement();

  // Type
  let typeText = 'Nothing selected';
  if (selectedElements.length > 1) {
    typeText = `${selectedElements.length} Selected`;
  } else if (el) {
    if (el.classList.contains('box')) typeText = 'Box';
    else if (el.classList.contains('svg-overlay')) typeText = 'SVG Overlay';
    else if (el.classList.contains('icon')) typeText = 'Icon';
    else typeText = 'Text';
  }
  document.getElementById('inspectType').textContent = typeText;

  // Position & Size
  document.getElementById('inspectX').disabled = !el;
  document.getElementById('inspectY').disabled = !el;
  document.getElementById('inspectW').disabled = !el;
  document.getElementById('inspectH').disabled = !el;
  
  if (el) {
    document.getElementById('inspectX').value = Math.round(parsePx(el.style.left));
    document.getElementById('inspectY').value = Math.round(parsePx(el.style.top));
    document.getElementById('inspectW').value = el.offsetWidth;
    document.getElementById('inspectH').value = el.offsetHeight;
  } else {
    document.getElementById('inspectX').value = '';
    document.getElementById('inspectY').value = '';
    document.getElementById('inspectW').value = '';
    document.getElementById('inspectH').value = '';
  }

  // SVG controls
  const isSVG = el && el.classList.contains('svg-overlay');
  svgOpacity.disabled = !isSVG;
  svgRotation.disabled = !isSVG;
  svgFillType.disabled = !isSVG;
  svgFillColor.disabled = !isSVG;
  svgGradStart.disabled = !isSVG;
  svgGradEnd.disabled = !isSVG;
  svgGradAngle.disabled = !isSVG;
  applySVGStyle.disabled = !isSVG;
  svgRotateLeft.disabled = !isSVG;
  svgRotate90.disabled = !isSVG;
  svgRotateRight.disabled = !isSVG;
  svgResetRotation.disabled = !isSVG;

  if (isSVG) {
    const opacity = parseFloat(el.style.opacity || 1);
    svgOpacity.value = Math.round(opacity * 100);
    document.getElementById('svgOpacityVal').textContent = Math.round(opacity * 100) + '%';
    
    const rotation = parseFloat(el.dataset.rotation || 0);
    svgRotation.value = rotation;
    document.getElementById('svgRotationVal').textContent = Math.round(rotation) + 'Â°';
    
    const fillType = el.dataset.fillType || 'none';
    svgFillType.value = fillType;
    
    document.getElementById('svgSolidColorSection').style.display = 
      fillType === 'solid' ? 'block' : 'none';
    document.getElementById('svgGradientSection').style.display = 
      fillType === 'gradient' ? 'block' : 'none';
    
    if (fillType === 'solid') {
      svgFillColor.value = el.dataset.fillColor || '#000000';
    } else if (fillType === 'gradient') {
      svgGradStart.value = el.dataset.gradStart || '#ff0000';
      svgGradEnd.value = el.dataset.gradEnd || '#0000ff';
      svgGradAngle.value = el.dataset.gradAngle || '45';
      document.getElementById('svgGradAngleVal').textContent = (el.dataset.gradAngle || '45') + 'Â°';
    }
  }

  // Box styling controls
  const isBox = el && el.classList.contains('box');
  boxOpacity.disabled = !isBox;
  boxBorderWidth.disabled = !isBox;
  boxBorderRadius.disabled = !isBox;
  boxBgColor.disabled = !isBox;
  boxBorderColor.disabled = !isBox;
  boxShadowType.disabled = !isBox;
  boxShadowColor.disabled = !isBox;
  boxShadowIntensity.disabled = !isBox;
  boxStyle.disabled = !isBox;

  if (isBox) {
    const computedStyle = getComputedStyle(el);
    const opacity = parseFloat(el.dataset.opacity || 1);
    boxOpacity.value = Math.round(opacity * 100);
    document.getElementById('boxOpacityVal').textContent = Math.round(opacity * 100) + '%';
    
    const borderWidth = parseInt(computedStyle.borderWidth) || 1;
    boxBorderWidth.value = borderWidth;
    document.getElementById('boxBorderWidthVal').textContent = borderWidth + 'px';
    
    const borderRadius = parseInt(computedStyle.borderRadius) || 12;
    boxBorderRadius.value = borderRadius;
    document.getElementById('boxBorderRadiusVal').textContent = borderRadius + 'px';
    
    boxBorderColor.value = rgbToHex(computedStyle.borderColor);
    const bgColor = el.dataset.bgColor || '#ffffff';
    boxBgColor.value = bgColor;
    
    boxShadowType.value = el.dataset.shadowType || 'none';
    boxShadowColor.value = el.dataset.shadowColor || '#000000';
    
    const shadowIntensity = parseFloat(el.dataset.shadowIntensity || 1);
    boxShadowIntensity.value = shadowIntensity;
    document.getElementById('boxShadowIntensityVal').textContent = shadowIntensity + 'x';
    
    const styleVal = el.dataset.boxStyle || 'default';
    boxStyle.value = styleVal === 'custom' ? 'custom' : styleVal;
  }

  // Custom CSS (works for boxes and SVGs)
  const canUseCSS = el && (el.classList.contains('box') || el.classList.contains('svg-overlay'));
  customCSS.disabled = !canUseCSS;
  applyCustomCSS.disabled = !canUseCSS;
  
  if (canUseCSS) {
    customCSS.value = el.dataset.customCSS || '';
  }

  // Text properties
  const isTextOrIcon = el && (el.classList.contains('text') || el.classList.contains('icon'));
  document.getElementById('textSize').disabled = !isTextOrIcon;
  document.getElementById('fontWeight').disabled = !isTextOrIcon;
  document.getElementById('fontFamily').disabled = !isTextOrIcon;
  document.getElementById('textColor').disabled = !isTextOrIcon;
  textElContent.disabled = !isTextOrIcon;
  textElType.disabled = !isTextOrIcon;
  
  // NEW: Text shadow controls
  textShadowType.disabled = !isTextOrIcon;
  textShadowColor.disabled = !isTextOrIcon;
  textShadowIntensity.disabled = !isTextOrIcon;

  if (isTextOrIcon) {
    const style = getComputedStyle(el);
    const fontSize = parseInt(style.fontSize) || 16;
    document.getElementById('textSize').value = fontSize;
    document.getElementById('textSizeVal').textContent = fontSize + 'px';
    document.getElementById('fontWeight').value = 
      style.fontWeight === 'bold' || parseInt(style.fontWeight) >= 700 ? '700' : 
      (parseInt(style.fontWeight) <= 300 ? '300' : '400');
    
    // Set font family - extract first font from font-family list
    const fontFamilyRaw = style.fontFamily || el.style.fontFamily || 'Roboto';
    const fontFamily = fontFamilyRaw.split(',')[0].replace(/['"]/g, '').trim();
    const fontSelect = document.getElementById('fontFamily');
    let found = false;
    for (let option of fontSelect.options) {
      if (option.value === fontFamily) {
        fontSelect.value = fontFamily;
        found = true;
        break;
      }
    }
    if (!found) fontSelect.value = 'Roboto';
    
    textElContent.value = getElText(el).trim();
    textElType.value = el.dataset.type || '';
    textColor.value = rgbToHex(style.color);
    lastUsedTextColor = rgbToHex(style.color); // keep global synced
    
    // NEW: Load text shadow settings
    textShadowType.value = el.dataset.textShadowType || 'none';
    textShadowColor.value = el.dataset.textShadowColor || '#000000';
    const textShadowInt = parseFloat(el.dataset.textShadowIntensity || 1);
    textShadowIntensity.value = textShadowInt;
    document.getElementById('textShadowIntensityVal').textContent = textShadowInt + 'x';
  } else {
    document.getElementById('textSizeVal').textContent = '--';
    document.getElementById('fontWeight').value = '400';
    document.getElementById('fontFamily').value = 'Roboto';
    textElContent.value = '';
    textElType.value = '';
    textColor.value = '#000000';
    
    // NEW: Reset text shadow UI
    textShadowType.value = 'none';
    textShadowColor.value = '#000000';
    textShadowIntensity.value = 1;
    document.getElementById('textShadowIntensityVal').textContent = '1x';
  }
}

// ====== BOX STYLING ======
function hexToRgba(hex, alpha = 1) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

boxOpacity.addEventListener('input', e => {
  const el = getSelectedElement();
  if (el && el.classList.contains('box')) {
    const opacity = parseFloat(e.target.value) / 100;
    el.dataset.opacity = opacity;
    const bgColor = el.dataset.bgColor || '#ffffff';
    el.style.background = hexToRgba(bgColor, opacity);
    document.getElementById('boxOpacityVal').textContent = e.target.value + '%';
  }
});
boxOpacity.addEventListener('change', () => saveAction('Change opacity'));

boxBorderWidth.addEventListener('input', e => {
  const el = getSelectedElement();
  if (el && el.classList.contains('box')) {
    el.style.borderWidth = e.target.value + 'px';
    document.getElementById('boxBorderWidthVal').textContent = e.target.value + 'px';
    el.dataset.boxStyle = 'custom';
    boxStyle.value = 'custom';
  }
});
boxBorderWidth.addEventListener('change', () => saveAction('Change border width'));

boxBorderRadius.addEventListener('input', e => {
  const el = getSelectedElement();
  if (el && el.classList.contains('box')) {
    el.style.borderRadius = e.target.value + 'px';
    document.getElementById('boxBorderRadiusVal').textContent = e.target.value + 'px';
    el.dataset.boxStyle = 'custom';
    boxStyle.value = 'custom';
  }
});
boxBorderRadius.addEventListener('change', () => saveAction('Change border radius'));

boxBgColor.addEventListener('change', e => {
  const el = getSelectedElement();
  if (el && el.classList.contains('box')) {
    saveAction('Change background color');
    el.dataset.bgColor = e.target.value;
    const opacity = parseFloat(el.dataset.opacity || 1);
    el.style.background = hexToRgba(e.target.value, opacity);
    el.dataset.boxStyle = 'custom';
    boxStyle.value = 'custom';
  }
});

boxBorderColor.addEventListener('change', e => {
  const el = getSelectedElement();
  if (el && el.classList.contains('box')) {
    saveAction('Change border color');
    el.style.borderColor = e.target.value;
    el.dataset.boxStyle = 'custom';
    boxStyle.value = 'custom';
  }
});

boxShadowType.addEventListener('change', e => {
  const el = getSelectedElement();
  if (el && el.classList.contains('box')) {
    saveAction('Change shadow type');
    const type = e.target.value;
    const color = boxShadowColor.value;
    const intensity = parseFloat(boxShadowIntensity.value);
    el.dataset.shadowType = type;
    el.dataset.shadowIntensity = intensity;
    applyShadow(el, type, color, intensity);
    el.dataset.boxStyle = 'custom';
    boxStyle.value = 'custom';
  }
});

boxShadowColor.addEventListener('change', e => {
  const el = getSelectedElement();
  if (el && el.classList.contains('box')) {
    saveAction('Change shadow color');
    const type = boxShadowType.value;
    const intensity = parseFloat(boxShadowIntensity.value);
    el.dataset.shadowColor = e.target.value;
    applyShadow(el, type, e.target.value, intensity);
    el.dataset.boxStyle = 'custom';
    boxStyle.value = 'custom';
  }
});

boxShadowIntensity.addEventListener('input', e => {
  const el = getSelectedElement();
  if (el && el.classList.contains('box')) {
    const intensity = parseFloat(e.target.value);
    const type = boxShadowType.value;
    const color = boxShadowColor.value;
    el.dataset.shadowIntensity = intensity;
    applyShadow(el, type, color, intensity);
    document.getElementById('boxShadowIntensityVal').textContent = intensity + 'x';
    el.dataset.boxStyle = 'custom';
    boxStyle.value = 'custom';
  }
});
boxShadowIntensity.addEventListener('change', () => saveAction('Change shadow intensity'));

function applyShadow(el, type, color, intensity = 1) {
  const colorRgba = hexToRgba(color, 0.4);
  const mult = intensity;
  switch(type) {
    case 'none':
      el.style.boxShadow = 'none';
      break;
    case 'light':
      el.style.boxShadow = `${2*mult}px ${2*mult}px ${8*mult}px ${colorRgba}`;
      break;
    case 'dark':
      el.style.boxShadow = `${4*mult}px ${4*mult}px ${12*mult}px ${colorRgba}`;
      break;
    case 'inset':
      el.style.boxShadow = `inset 0 ${2*mult}px ${8*mult}px ${colorRgba}`;
      break;
    case 'glow':
      el.style.boxShadow = `0 0 ${20*mult}px ${colorRgba}`;
      break;
  }
}

// NEW: Text shadow function
function applyTextShadow(el, type, color, intensity = 1) {
  // Apply shadow to the .el-content child, not the parent
  const content = el.querySelector('.el-content');
  if (!content) return;
  
  const mult = intensity;
  switch(type) {
    case 'none':
      content.style.textShadow = 'none';
      break;
    case 'light':
      content.style.textShadow = `${1*mult}px ${1*mult}px ${2*mult}px ${color}`;
      break;
    case 'dark':
      content.style.textShadow = `${2*mult}px ${2*mult}px ${4*mult}px ${color}`;
      break;
    case 'glow':
      content.style.textShadow = `0 0 ${10*mult}px ${color}, 0 0 ${20*mult}px ${color}`;
      break;
    case 'outline':
      // Create outline effect with multiple shadows
      const offset = 1 * mult;
      content.style.textShadow = `
        -${offset}px -${offset}px 0 ${color},
        ${offset}px -${offset}px 0 ${color},
        -${offset}px ${offset}px 0 ${color},
        ${offset}px ${offset}px 0 ${color}
      `;
      break;
  }
}

// NEW: Text shadow event listeners
textShadowType.addEventListener('change', e => {
  const el = getSelectedElement();
  if (el && (el.classList.contains('text') || el.classList.contains('icon'))) {
    saveAction('Change text shadow type');
    const type = e.target.value;
    const color = textShadowColor.value;
    const intensity = parseFloat(textShadowIntensity.value);
    el.dataset.textShadowType = type;
    el.dataset.textShadowIntensity = intensity;
    applyTextShadow(el, type, color, intensity);
  }
});

textShadowColor.addEventListener('change', e => {
  const el = getSelectedElement();
  if (el && (el.classList.contains('text') || el.classList.contains('icon'))) {
    saveAction('Change text shadow color');
    const type = textShadowType.value;
    const intensity = parseFloat(textShadowIntensity.value);
    el.dataset.textShadowColor = e.target.value;
    applyTextShadow(el, type, e.target.value, intensity);
  }
});

textShadowIntensity.addEventListener('input', e => {
  const el = getSelectedElement();
  if (el && (el.classList.contains('text') || el.classList.contains('icon'))) {
    const intensity = parseFloat(e.target.value);
    const type = textShadowType.value;
    const color = textShadowColor.value;
    el.dataset.textShadowIntensity = intensity;
    applyTextShadow(el, type, color, intensity);
    document.getElementById('textShadowIntensityVal').textContent = intensity + 'x';
  }
});
textShadowIntensity.addEventListener('change', () => saveAction('Change text shadow intensity'));

// NEW: Multi-select apply functions
document.getElementById('applyColorToAll').addEventListener('click', () => {
  const textIconElements = selectedElements.filter(el => 
    el.classList.contains('text') || el.classList.contains('icon')
  );
  
  if (textIconElements.length > 1) {
    saveAction('Apply color to all selected');
    const color = textColor.value;
    textIconElements.forEach(el => {
      el.style.color = color;
    });
    setStatus(`Applied color to ${textIconElements.length} elements`, 2000);
  }
});

document.getElementById('applyShadowToAll').addEventListener('click', () => {
  const textIconElements = selectedElements.filter(el => 
    el.classList.contains('text') || el.classList.contains('icon')
  );
  
  if (textIconElements.length > 1) {
    saveAction('Apply shadow to all selected');
    const type = textShadowType.value;
    const color = textShadowColor.value;
    const intensity = parseFloat(textShadowIntensity.value);
    
    textIconElements.forEach(el => {
      el.dataset.textShadowType = type;
      el.dataset.textShadowColor = color;
      el.dataset.textShadowIntensity = intensity;
      applyTextShadow(el, type, color, intensity);
    });
    setStatus(`Applied shadow to ${textIconElements.length} elements`, 2000);
  }
});

document.getElementById('textSize').addEventListener('input', e => {
  const el = getSelectedElement();
  if (el) { 
    el.style.fontSize = e.target.value + 'px'; 
    document.getElementById('textSizeVal').textContent = e.target.value + 'px'; 
  }
});
document.getElementById('textSize').addEventListener('change', () => saveAction('Change font size'));

document.getElementById('fontWeight').addEventListener('change', e => {
  const el = getSelectedElement();
  if (el) { saveAction('Change font weight'); el.style.fontWeight = e.target.value; }
});

document.getElementById('fontFamily').addEventListener('change', e => {
  const el = getSelectedElement();
  if (el) { 
    saveAction('Change font family'); 
    el.style.fontFamily = `'${e.target.value}', sans-serif`;
  }
});

textColor.addEventListener('change', e => {
  const el = getSelectedElement();
  if (el) {
    saveAction('Change text color');
    el.style.color = e.target.value;
    lastUsedTextColor = e.target.value; localStorage.setItem('lastUsedTextColor', lastUsedTextColor); // store globally and persist
  }
});

textElContent.addEventListener('input', e => {
  const el = getSelectedElement();
  if (el) { setElText(el, e.target.value); }
});
textElContent.addEventListener('change', () => saveAction('Change content'));

textElType.addEventListener('change', e => {
  const el = getSelectedElement();
  if (el) { 
    saveAction('Change data type'); 
    el.dataset.type = e.target.value;
  }
});

boxStyle.addEventListener('change', e => {
  const el = getSelectedElement();
  if (el && el.classList.contains('box')) {
    saveAction('Change box style');
    const style = e.target.value;
    el.dataset.boxStyle = style;
    
    el.classList.remove('box-abstract', 'box-geometric', 'box-paper-collage', 'box-kids-shapes', 'box-minimal');
    
    if (style !== 'custom') {
      el.dataset.opacity = '1';
      el.style.borderWidth = '';
      el.style.borderRadius = '';
      el.style.borderColor = '';
      el.style.background = '';
      el.style.boxShadow = '';
      el.dataset.shadowType = 'none';
      el.dataset.shadowIntensity = '1';
      
      if (style !== 'default') {
        el.classList.add('box-' + style);
      }
    }
    
    updateInspector();
  }
});

// ====== CUSTOM CSS ======
function loadSavedCSSPresets() {
  const saved = localStorage.getItem('customCSSPresets');
  return saved ? JSON.parse(saved) : [];
}

function saveCSSPresets(presets) {
  localStorage.setItem('customCSSPresets', JSON.stringify(presets));
}

function updateCSSList() {
  const presets = loadSavedCSSPresets();
  savedCSSList.innerHTML = '<option value="">-- Saved CSS Presets --</option>';
  presets.forEach((preset, index) => {
    const opt = document.createElement('option');
    opt.value = index;
    opt.textContent = preset.name;
    savedCSSList.appendChild(opt);
  });
  savedCSSList.disabled = presets.length === 0;
}

applyCustomCSS.addEventListener('click', () => {
  const el = getSelectedElement();
  if (el && (el.classList.contains('box') || el.classList.contains('svg-overlay'))) {
    saveAction('Apply custom CSS');
    const css = customCSS.value.trim();
    if (css) {
      const rules = css.split(';').filter(r => r.trim());
      rules.forEach(rule => {
        const [prop, val] = rule.split(':').map(s => s.trim());
        if (prop && val) {
          el.style[prop.replace(/-([a-z])/g, (g) => g[1].toUpperCase())] = val;
        }
      });
      if (el.classList.contains('box')) {
        el.dataset.boxStyle = 'custom';
        boxStyle.value = 'custom';
      }
      el.dataset.customCSS = css;
      updateInspector();
      setStatus('Custom CSS applied', 2000);
    }
  }
});

document.getElementById('saveCustomCSS').addEventListener('click', () => {
  const css = customCSS.value.trim();
  if (!css) {
    setStatus('No CSS to save', 2000);
    return;
  }
  const name = prompt('Enter a name for this CSS preset:');
  if (name) {
    const presets = loadSavedCSSPresets();
    presets.push({ name, css });
    saveCSSPresets(presets);
    updateCSSList();
    setStatus('CSS preset saved', 2000);
  }
});

document.getElementById('loadCustomCSS').addEventListener('click', () => {
  updateCSSList();
});

savedCSSList.addEventListener('change', e => {
  if (e.target.value !== '') {
    const presets = loadSavedCSSPresets();
    const preset = presets[parseInt(e.target.value)];
    if (preset) {
      customCSS.value = preset.css;
      setStatus(`Loaded: ${preset.name}`, 2000);
    }
  }
});

updateCSSList();

// ====== ELEMENT MANAGEMENT ======
function makeEl(cls, x = 50, y = 50, w = 160, h = 80) {
  const el = document.createElement('div');
  el.className = 'el ' + cls;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  el.style.width = w + 'px';
  el.style.height = h + 'px';
  
  const content = document.createElement('div');
  content.className = 'el-content';
  el.appendChild(content);
  
  const handle = document.createElement('div');
  handle.className = 'resize-handle';
  el.appendChild(handle);
  
  canvas.appendChild(el);
  return el;
}

function clearCanvas() {
  [...canvas.children].forEach(n => {
    if (n.classList.contains('el')) n.remove();
  });
  selectedElements = [];
}

function setElText(el, text) {
  const content = el.querySelector('.el-content');
  if (content) {
    content.textContent = text;
  }
}

function getElText(el) {
  const content = el.querySelector('.el-content');
  return content ? content.textContent : '';
}

function renderLayout(data, saveToHistory = true) {
  clearCanvas();
  (data.elements || []).forEach(elData => {
    if (elData.kind === 'svg') {
      // Render SVG element
      const el = createSVGElement(elData.svgContent, elData.x, elData.y, elData.w, elData.h);
      if (elData.fillType) {
        el.dataset.fillType = elData.fillType;
        if (elData.fillColor) el.dataset.fillColor = elData.fillColor;
        if (elData.gradStart) el.dataset.gradStart = elData.gradStart;
        if (elData.gradEnd) el.dataset.gradEnd = elData.gradEnd;
        if (elData.gradAngle) el.dataset.gradAngle = elData.gradAngle;
        applySVGFill(el);
      }
      if (elData.rotation !== undefined) {
        el.dataset.rotation = elData.rotation;
        applySVGFill(el); // Reapply to set rotation
      }
      if (elData.opacity !== undefined) {
        el.style.opacity = elData.opacity;
      }
      if (elData.customCSS) {
        el.dataset.customCSS = elData.customCSS;
      }
    } else {
      // Regular element
      const div = makeEl(elData.kind || 'box', elData.x, elData.y, elData.w, elData.h);
      if (elData.text) setElText(div, elData.text);
      if (elData.color) div.style.color = elData.color;
      if (elData.weight) div.style.fontWeight = elData.weight;
      if (elData.fontSize) div.style.fontSize = elData.fontSize + 'px';
      if (elData.fontFamily) div.style.fontFamily = `'${elData.fontFamily}', sans-serif`;
      if (elData.type) div.dataset.type = elData.type;
      
      // NEW: Restore text shadow data
      if (elData.textShadowType && elData.textShadowType !== 'none') {
        div.dataset.textShadowType = elData.textShadowType;
        div.dataset.textShadowColor = elData.textShadowColor || '#000000';
        div.dataset.textShadowIntensity = elData.textShadowIntensity || 1;
        applyTextShadow(div, elData.textShadowType, elData.textShadowColor || '#000000', elData.textShadowIntensity || 1);
      }
      
      if (elData.style) {
        div.dataset.boxStyle = elData.style;
        if (elData.style !== 'default' && elData.style !== 'custom') {
          div.classList.add('box-' + elData.style);
        }
      }
      if (elData.opacity !== undefined) {
        div.dataset.opacity = elData.opacity;
      }
      if (elData.kind === 'box' || !elData.kind) {
        const bgColor = elData.bgColor || '#ffffff';
        div.dataset.bgColor = bgColor;
        const opacity = elData.opacity !== undefined ? elData.opacity : 1;
        div.style.background = hexToRgba(bgColor, opacity);
      }
      if (elData.borderWidth) div.style.borderWidth = elData.borderWidth + 'px';
      if (elData.borderRadius) div.style.borderRadius = elData.borderRadius + 'px';
      if (elData.borderColor) div.style.borderColor = elData.borderColor;
      if (elData.shadowType) {
        div.dataset.shadowType = elData.shadowType;
        if (elData.shadowColor) div.dataset.shadowColor = elData.shadowColor;
        const shadowIntensity = elData.shadowIntensity || 1;
        div.dataset.shadowIntensity = shadowIntensity;
        applyShadow(div, elData.shadowType, elData.shadowColor || '#000000', shadowIntensity);
      }
      if (elData.customCSS) {
        div.dataset.customCSS = elData.customCSS;
        const rules = elData.customCSS.split(';').filter(r => r.trim());
        rules.forEach(rule => {
          const [prop, val] = rule.split(':').map(s => s.trim());
          if (prop && val) {
            div.style[prop.replace(/-([a-z])/g, (g) => g[1].toUpperCase())] = val;
          }
        });
      }
    }
  });
  
  if (saveToHistory) saveAction('Render layout');
  selectEl(null, false);
}

// ====== DRAG & RESIZE ======
canvas.addEventListener('mousedown', e => {
  if (e.target === canvas || e.target === gridOverlay || e.target.id === 'bg') {
    selectEl(null, false);
    return;
  }
  
  const el = e.target.closest('.el');
  if (!el) return;
  
  // NEW: Allow shift+click for multi-select on text/icon elements
  const isMultiSelect = e.shiftKey && (el.classList.contains('text') || el.classList.contains('icon'));
  
  if (e.target.classList.contains('resize-handle')) {
    e.preventDefault();
    resizeData = {
      el,
      startMouseX: e.clientX,
      startMouseY: e.clientY,
      startW: el.offsetWidth,
      startH: el.offsetHeight
    };
  } else {
    selectEl(el, isMultiSelect);
    
    e.preventDefault();
    const zoom = parseFloat(document.getElementById('zoomSlider').value) / 100;
    dragData = {
      isGroup: selectedElements.length > 1,
      elements: selectedElements.map(item => ({
        el: item,
        startX: parsePx(item.style.left),
        startY: parsePx(item.style.top)
      })),
      startMouseX: e.clientX,
      startMouseY: e.clientY,
      zoom
    };
  }
});

window.addEventListener('mousemove', e => {
  if (resizeData) {
    const dx = e.clientX - resizeData.startMouseX;
    const dy = e.clientY - resizeData.startMouseY;
    const zoom = parseFloat(document.getElementById('zoomSlider').value) / 100;
    const nw = Math.max(20, resizeData.startW + dx / zoom);
    const nh = Math.max(20, resizeData.startH + dy / zoom);
    resizeData.el.style.width = nw + 'px';
    resizeData.el.style.height = nh + 'px';
    
    updateInspector();
  } else if (dragData) {
    const deltaX = (e.clientX - dragData.startMouseX) / dragData.zoom;
    const deltaY = (e.clientY - dragData.startMouseY) / dragData.zoom;
    
    dragData.elements.forEach(item => {
      let nx = item.startX + deltaX;
      let ny = item.startY + deltaY;
      // Remove bounds constraints - allow elements to move freely beyond canvas
      item.el.style.left = snapToGrid(nx) + 'px';
      item.el.style.top = snapToGrid(ny) + 'px';
    });
    
    updateInspector();
  }
});

window.addEventListener('mouseup', () => {
  if (dragData && dragData.isGroup) {
    setStatus(`Moved ${selectedElements.length} elements`, 1500);
  }
  if (dragData) saveAction('Move element');
  if (resizeData) saveAction('Resize element');
  dragData = resizeData = null;
});

// ====== ADD ELEMENTS ======
function addElement(kind, options = {}) {
  saveAction('Add element');
  
  let x = options.x ?? 100;
  let y = options.y ?? 100;
  let w = options.w ?? 150;
  let h = options.h ?? 50;
  
  if (selectedBoxForDrop) {
    const boxRect = {
      left: parsePx(selectedBoxForDrop.style.left),
      top: parsePx(selectedBoxForDrop.style.top),
      width: selectedBoxForDrop.offsetWidth,
      height: selectedBoxForDrop.offsetHeight
    };
    x = boxRect.left + (boxRect.width - w) / 2;
    y = boxRect.top + (boxRect.height - h) / 2;
  }
  
  const el = makeEl(kind, x, y, w, h);
  setElText(el, options.text ?? (kind === 'box' ? '' : kind.charAt(0).toUpperCase() + kind.slice(1)));
  if (options.fontSize) el.style.fontSize = options.fontSize + 'px';
  if (options.fontWeight) el.style.fontWeight = options.fontWeight;
  if (options.color) el.style.color = options.color;
  else if (kind === 'text' || kind === 'icon') el.style.color = lastUsedTextColor || '#000000';
  if (options.type) el.dataset.type = options.type;
  if (options.style) {
    el.dataset.boxStyle = options.style;
    if (options.style !== 'default') {
      el.classList.add('box-' + options.style);
    }
  }
  
  if (kind === 'box') {
    const shadowType = options.shadowType || 'dark';
    const shadowColor = options.shadowColor || '#000000';
    const shadowIntensity = options.shadowIntensity || 1;
    const opacity = options.opacity !== undefined ? options.opacity : 0.3;
    el.dataset.shadowType = shadowType;
    el.dataset.shadowColor = shadowColor;
    el.dataset.shadowIntensity = shadowIntensity;
    el.dataset.opacity = opacity;
    el.dataset.bgColor = options.bgColor || '#ffffff';
    el.style.background = hexToRgba(el.dataset.bgColor, opacity);
    applyShadow(el, shadowType, shadowColor, shadowIntensity);
  }
  
  if (kind === 'text' || kind === 'icon') {
    if (!options.fontSize) {
      el.style.fontSize = Math.max(12, Math.floor((options.h ?? 50) * 0.6)) + 'px';
    }
  }
  selectEl(el, false);
  setStatus(`Added ${kind}`, 1500);
}

document.getElementById('quickAddBox').onclick = () => {
  addElement('box', {w:300, h:120, text:'', style:'default', shadowType:'dark', shadowColor:'#000000', opacity:0.3});
};

document.getElementById('quickAddInfo').onclick = (e) => {
  const dropdown = document.getElementById('infoDropdown');
  dropdown.classList.toggle('show');
  const rect = e.currentTarget.getBoundingClientRect();
  dropdown.style.left = rect.left + 'px';
  dropdown.style.top = rect.bottom + 5 + 'px';
};

document.querySelectorAll('.info-option').forEach(opt => {
  opt.onclick = () => {
    const type = opt.dataset.type;
    const defaultText = {
      'WEATHER_CITY': 'Darwin',
      'WEATHER_MINMAX': '26Â° / 33Â°',
      'WEATHER_NOTE': 'Sunny',
      'WEATHER_ICON': 'â˜€ï¸',
      'JOKE': 'Dad joke here...',
      'DATE': 'Mon, 27 Oct',
      '': 'Text'
    };
    
    const isIcon = type === 'WEATHER_ICON';
    const kind = isIcon ? 'icon' : 'text';
    const size = isIcon ? {w:64, h:64} : {w:200, h:40};
    
    addElement(kind, {
      ...size,
      text: defaultText[type],
      type: type,
      color: '#000000', 
      fontSize: type === 'JOKE' ? 20 : (type === 'DATE' || type === 'WEATHER_CITY' ? 20 : 16),
      fontWeight: type === 'DATE' || type === 'WEATHER_CITY' ? '700' : '400'
    });
    
    document.getElementById('infoDropdown').classList.remove('show');
  };
});

document.addEventListener('click', (e) => {
  if (!e.target.closest('#quickAddInfo') && !e.target.closest('.info-dropdown')) {
    document.getElementById('infoDropdown').classList.remove('show');
  }
});

document.getElementById('deleteBtn').onclick = () => { 
  if (selectedElements.length > 0) { 
    saveAction('Delete element(s)');
    selectedElements.forEach(el => el.remove());
    selectedElements = [];
    selectEl(null, false); 
    setStatus('Deleted', 1500); 
  } 
};

// ====== ALIGNMENT ======
function alignElements() {
  if (selectedElements.length === 2) {
    return selectedElements[0];
  } else if (selectedElements.length === 1) {
    return null;
  }
  return null;
}

const align = (prop, valueFn) => () => {
  const reference = alignElements();
  if (selectedElements.length === 0) return;
  
  saveAction('Align elements');
  
  if (selectedElements.length === 2 && reference) {
    const target = selectedElements[1];
    target.style[prop] = valueFn(target, reference) + 'px';
  } else if (selectedElements.length === 1) {
    selectedElements.forEach(el => {
      el.style[prop] = valueFn(el, null) + 'px';
    });
  }
  
  setStatus(`Aligned ${prop}`, 1500);
  updateInspector();
};

document.getElementById('alignLeft').onclick = align('left', (el, ref) => 
  ref ? parsePx(ref.style.left) : 20
);
document.getElementById('alignCenter').onclick = align('left', (el, ref) => 
  ref ? parsePx(ref.style.left) + (ref.offsetWidth - el.offsetWidth) / 2 : (800 - el.offsetWidth) / 2
);
document.getElementById('alignRight').onclick = align('left', (el, ref) => 
  ref ? parsePx(ref.style.left) + ref.offsetWidth - el.offsetWidth : 800 - el.offsetWidth - 20
);
document.getElementById('alignTop').onclick = align('top', (el, ref) => 
  ref ? parsePx(ref.style.top) : 20
);
document.getElementById('alignMiddle').onclick = align('top', (el, ref) => 
  ref ? parsePx(ref.style.top) + (ref.offsetHeight - el.offsetHeight) / 2 : (480 - el.offsetHeight) / 2
);
document.getElementById('alignBottom').onclick = align('top', (el, ref) => 
  ref ? parsePx(ref.style.top) + ref.offsetHeight - el.offsetHeight : 480 - el.offsetHeight - 20
);

// Bring to Canvas - moves element to nearest edge if out of bounds
document.getElementById('bringToCanvas').onclick = () => {
  if (selectedElements.length === 0) return;
  
  saveAction('Bring to canvas');
  
  selectedElements.forEach(el => {
    let x = parsePx(el.style.left);
    let y = parsePx(el.style.top);
    const w = el.offsetWidth;
    const h = el.offsetHeight;
    
    // Constrain to canvas bounds with 20px padding
    x = Math.max(20, Math.min(x, 800 - w - 20));
    y = Math.max(20, Math.min(y, 480 - h - 20));
    
    el.style.left = x + 'px';
    el.style.top = y + 'px';
  });
  
  setStatus('Brought to canvas', 1500);
  updateInspector();
};

// ====== POSITION CONTROLS ======
['inspectX', 'inspectY', 'inspectW', 'inspectH'].forEach(id => {
  const input = document.getElementById(id);
  input.addEventListener('change', () => {
    const el = getSelectedElement();
    if (!el) return;
    saveAction('Change position/size');
    if (id === 'inspectX') el.style.left = input.value + 'px';
    if (id === 'inspectY') el.style.top = input.value + 'px';
    if (id === 'inspectW') el.style.width = input.value + 'px';
    if (id === 'inspectH') el.style.height = input.value + 'px';
  });
});

// ====== PNG EXPORT FIX ======
async function renderSVGToCanvas(ctx, el, x, y, w, h) {
  return new Promise((resolve) => {
    ctx.save();
    
    const opacity = parseFloat(el.style.opacity || 1);
    ctx.globalAlpha = opacity;
    
    const svg = el.querySelector('svg');
    if (!svg) {
      ctx.fillStyle = 'rgba(200,100,100,0.3)';
      ctx.fillRect(x, y, w, h);
      ctx.restore();
      resolve();
      return;
    }
    
    const svgElement = svg.cloneNode(true);
    svgElement.setAttribute('width', w);
    svgElement.setAttribute('height', h);
    // Remove CSS transform from clone - rotation will be applied in canvas
    svgElement.style.transform = '';
    svgElement.style.transformOrigin = '';
    
    const svgContent = new XMLSerializer().serializeToString(svgElement);
    
    if (!svgContent || svgContent.trim() === '') {
      ctx.restore();
      resolve();
      return;
    }
    
    const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const img = new Image();
    
    img.onload = function() {
      try {
        const rotation = parseFloat(el.dataset.rotation || 0);
        if (rotation !== 0) {
          ctx.save();
          ctx.translate(x + w/2, y + h/2);
          ctx.rotate((rotation * Math.PI) / 180);
          ctx.drawImage(img, -w/2, -h/2, w, h);
          ctx.restore();
        } else {
          ctx.drawImage(img, x, y, w, h);
        }
      } catch (e) {
        console.error('Error rendering SVG:', e);
      }
      URL.revokeObjectURL(url);
      ctx.restore();
      resolve();
    };
    
    img.onerror = function(e) {
      console.error('Failed to load SVG image:', e);
      ctx.fillStyle = 'rgba(200,100,100,0.3)';
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = '#933';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('SVG (failed to load)', x + w/2, y + h/2);
      ctx.restore();
      URL.revokeObjectURL(url);
      resolve();
    };
    
    img.src = url;
  });
}

function renderBoxToCanvas(ctx, el, x, y, w, h) {
  const boxStyleVal = el.dataset.boxStyle || 'default';
  const computedStyle = getComputedStyle(el);
  
  ctx.save();
  
  // Apply opacity from dataset (which handles the slider)
  const opacity = parseFloat(el.dataset.opacity || el.style.opacity || 1);
  ctx.globalAlpha = opacity;
  
  if (boxStyleVal === 'custom' || boxStyleVal === 'default') {
    // Use the stored background color and apply opacity
    const bgColor = el.dataset.bgColor || '#ffffff';
    // The background color from 'hexToRgba' in the styling logic already includes opacity,
    // but for canvas, we set globalAlpha and fill with the solid color.
    ctx.fillStyle = bgColor;
    
    const borderRadius = parseInt(computedStyle.borderRadius) || 12;
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, borderRadius);
    ctx.fill();
    
    const borderWidth = parseInt(computedStyle.borderWidth) || 1;
    if (borderWidth > 0) {
        ctx.strokeStyle = computedStyle.borderColor;
        ctx.lineWidth = borderWidth;
        ctx.stroke();
    }
  }
  // Note: This simplified box render doesn't re-draw the complex CSS styles
  // from 'box-abstract', 'box-geometric' etc. It favors the 'custom'/'default' path.
  // For full fidelity, those styles would also need to be drawn to canvas.
  
  ctx.restore();
}

function renderTextToCanvas(ctx, el, x, y, w, h) {
  const content = el.querySelector('.el-content');
  const style = getComputedStyle(content || el);
  const text = getElText(el).trim();
  
  ctx.save();
  ctx.fillStyle = style.color;
  
  let fontFamily = style.fontFamily;
  if (el.classList.contains('icon')) {
    // Ensure emoji font is prioritized for icons
    fontFamily = '"Segoe UI Emoji", "Noto Color Emoji", "Apple Color Emoji", sans-serif';
  }
  
  ctx.font = `${style.fontWeight} ${style.fontSize} ${fontFamily}`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // NEW: Apply text shadow if present
  if (el.dataset.textShadowType && el.dataset.textShadowType !== 'none') {
    const shadowType = el.dataset.textShadowType;
    const shadowColor = el.dataset.textShadowColor || '#000000';
    const intensity = parseFloat(el.dataset.textShadowIntensity || 1);
    const mult = intensity;
    
    switch(shadowType) {
      case 'light':
        ctx.shadowColor = shadowColor;
        ctx.shadowBlur = 2 * mult;
        ctx.shadowOffsetX = 1 * mult;
        ctx.shadowOffsetY = 1 * mult;
        break;
      case 'dark':
        ctx.shadowColor = shadowColor;
        ctx.shadowBlur = 4 * mult;
        ctx.shadowOffsetX = 2 * mult;
        ctx.shadowOffsetY = 2 * mult;
        break;
      case 'glow':
        ctx.shadowColor = shadowColor;
        ctx.shadowBlur = 20 * mult;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        break;
      case 'outline':
        // Outline needs multiple passes - draw background first
        const offset = 1 * mult;
        ctx.strokeStyle = shadowColor;
        ctx.lineWidth = offset * 2;
        ctx.strokeText(text, x + w / 2, y + h / 2);
        break;
    }
  }
  
  ctx.fillText(text, x + w / 2, y + h / 2);
  ctx.restore();
}

document.getElementById('btnDownloadPNG').onclick = async () => {
  try {
    setStatus('Exporting PNG...', 0);
    
    const ex = document.getElementById('exportCanvas');
    const ctx = ex.getContext('2d');
    ctx.clearRect(0, 0, 800, 480);
    
    // 1. Draw Background (with CORS handling)
    const bgImg = document.getElementById('bg');
    if(bgImg.complete && bgImg.src && bgImg.src !== window.location.href) {
      try {
        ctx.drawImage(bgImg, 0, 0, 800, 480);
      } catch (corsError) {
        // CORS error - fill with dark background instead
        console.warn('Background image has CORS restrictions, using solid color');
        ctx.fillStyle = '#111111';
        ctx.fillRect(0, 0, 800, 480);
      }
    } else {
      // No background - use dark fill
      ctx.fillStyle = '#111111';
      ctx.fillRect(0, 0, 800, 480);
    }
    
    // 2. Draw Elements in order
    const els = [...canvas.querySelectorAll('.el')];
    
    for (const el of els) {
      const x = parsePx(el.style.left);
      const y = parsePx(el.style.top);
      const w = el.offsetWidth;
      const h = el.offsetHeight;
      
      if (el.classList.contains('svg-overlay')) {
        // Use the new async SVG renderer
        await renderSVGToCanvas(ctx, el, x, y, w, h);
      } else if (el.classList.contains('box')) {
        // Use the box renderer
        renderBoxToCanvas(ctx, el, x, y, w, h);
      } else {
        // Use the text/icon renderer
        renderTextToCanvas(ctx, el, x, y, w, h);
      }
    }

    // 3. Trigger Download
    const a = document.createElement('a');
    const name = presetNameInput.value.trim() || currentPresetName || 'kind-layout';
    a.download = `${name}.png`;
    a.href = ex.toDataURL('image/png');
    a.click();
    setStatus('PNG exported âœ“', 1500);
  } catch (error) {
    console.error('PNG Export Error:', error);
    setStatus('PNG export failed - check console', 3000);
    alert('PNG export failed. Error: ' + error.message);
  }
};
// ====== END: PNG EXPORT FIX ======


// ====== TEMPLATES ======
function applyTemplate(key) {
  const tpl = TEMPLATES[key];
  if (!tpl) return;
  
  currentTemplateKey = key;
  currentPresetName = key;
  presetNameInput.value = key;
  templateSelect.value = key;
  
  originalTemplate = { elements: tpl.elements };
  
  renderLayout({ elements: tpl.elements });
  setStatus(`Loaded: ${tpl.name}`, 2000);
}

templateSelect.onchange = () => applyTemplate(templateSelect.value);

document.getElementById('resetBtn').onclick = () => {
  if (originalTemplate && confirm('Reset to original preset?')) {
    renderLayout(originalTemplate);
    setStatus('Reset to original', 1500);
  }
};

// ====== KEYBOARD SHORTCUTS ======
document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
    return;
  }
  
  if (e.key === 'Delete' || e.key === 'Backspace') {
    e.preventDefault();
    document.getElementById('deleteBtn').click();
  }
  
  if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
    e.preventDefault();
    undo();
  }
  
  if (((e.ctrlKey || e.metaKey) && e.key === 'y') || 
      ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z')) {
    e.preventDefault();
    redo();
  }
  
  if (e.key === 'Escape') {
    e.preventDefault();
    selectEl(null, false);
    setStatus('Deselected', 1000);
  }
});

document.getElementById('undoBtn').onclick = undo;
document.getElementById('redoBtn').onclick = redo;

// ====== ZOOM ======
document.getElementById('zoomSlider').addEventListener('input', e => {
  const z = e.target.value / 100;
  document.getElementById('zoomStage').style.transform = `scale(${z})`;
  document.getElementById('zoomLabel').textContent = e.target.value + '%';
});

document.getElementById('fitBtn').onclick = () => {
  const stageWrap = document.querySelector('.stage-wrap');
  const zw = (stageWrap.clientWidth - 40) / 800;
  const zh = (stageWrap.clientHeight - 40) / 480;
  document.getElementById('zoomSlider').value = Math.min(zw, zh) * 100;
  document.getElementById('zoomSlider').dispatchEvent(new Event('input'));
};

document.getElementById('toggleGrid').onclick = () => gridOverlay.classList.toggle('active');

// ====== PANEL COLLAPSE/EXPAND ======
function setupPanelToggles() {
  document.querySelectorAll('.panel h3').forEach(header => {
    header.onclick = () => {
      const panel = header.parentElement;
      panel.classList.toggle('collapsed');
    };
  });
}

function autoCollapsePanels() {
  const el = getSelectedElement();
  const boxPanel = document.getElementById('boxStylePanel');
  const textPanel = document.getElementById('textControlPanel');
  const svgPanel = document.getElementById('svgStylePanel');
  const cssPanel = document.getElementById('customCSSPanel');
  
  // Check if CSS panel was manually opened (if it's not collapsed, user opened it)
  const cssWasOpen = !cssPanel.classList.contains('collapsed');
  
  if (!el) {
    boxPanel.classList.add('collapsed');
    textPanel.classList.add('collapsed');
    svgPanel.classList.add('collapsed');
    // Don't auto-collapse CSS panel if user manually opened it
    if (!cssWasOpen) {
      cssPanel.classList.add('collapsed');
    }
  } else if (el.classList.contains('box')) {
    boxPanel.classList.remove('collapsed');
    textPanel.classList.add('collapsed');
    svgPanel.classList.add('collapsed');
    // Keep CSS panel state as user set it
  } else if (el.classList.contains('text') || el.classList.contains('icon')) {
    boxPanel.classList.add('collapsed');
    textPanel.classList.remove('collapsed');
    svgPanel.classList.add('collapsed');
    // CSS panel stays collapsed for text/icons
    if (!cssWasOpen) {
      cssPanel.classList.add('collapsed');
    }
  } else if (el.classList.contains('svg-overlay')) {
    boxPanel.classList.add('collapsed');
    textPanel.classList.add('collapsed');
    svgPanel.classList.remove('collapsed');
    // Keep CSS panel state as user set it
  }
}

// ====== INITIALIZATION ======
function start() {
  // Initialize lastUsedTextColor from inspector value
  if (document.getElementById('textColor')) {
    document.getElementById('textColor').value = lastUsedTextColor; // sync picker with stored color
    lastUsedTextColor = document.getElementById('textColor').value || '#000000';
  }
  drawGrid();
  loadThemeBackground();
  
  setupPanelToggles();
  
  document.getElementById('boxStylePanel').classList.add('collapsed');
  document.getElementById('textControlPanel').classList.add('collapsed');
  document.getElementById('svgStylePanel').classList.add('collapsed');
  document.getElementById('customCSSPanel').classList.add('collapsed');
  
  Object.keys(TEMPLATES).forEach(key => {
    const tpl = TEMPLATES[key];
    const o = document.createElement('option');
    o.value = key;
    o.textContent = tpl.name;
    templateSelect.appendChild(o);
  });

  // applyTemplate('sticker_parade_dark'); // disabled for blank start
  setStatus('Ready to design âœ“', 2000);
  
  console.log('âœ… kin;D Designer SVG Enhanced v2.2 loaded');
  console.log('ğŸ¨ New: SVG import with gradient fills');
  console.log('ğŸ’¡ Custom CSS works with boxes and SVGs (UIverse compatible)');
  console.log('âŒ¨ï¸ Shortcuts: Ctrl+Z (Undo), Ctrl+Y (Redo), ESC (Deselect), Del (Delete)');
  console.log('âœ¨ NEW: Text shadow/glow + Multi-select for text (Shift+Click)');
}

start();
</script>

</body>
</html>